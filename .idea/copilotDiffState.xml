<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/frontend/src/App.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/App.tsx" />
              <option name="originalContent" value="import React from 'react';&#10;import { BrowserRouter as Router } from 'react-router-dom';&#10;import { Provider } from 'react-redux';&#10;import { ThemeProvider } from '@mui/material/styles';&#10;import { CssBaseline } from '@mui/material';&#10;import { QueryClient, QueryClientProvider } from '@tanstack/react-query';&#10;import { store } from './store/store';&#10;import theme from './theme';&#10;import AppRoutes from './routes/AppRoutes';&#10;import AuthInitializer from './components/AuthInitializer';&#10;&#10;const queryClient = new QueryClient();&#10;&#10;function App() {&#10;  return (&#10;    &lt;QueryClientProvider client={queryClient}&gt;&#10;      &lt;Provider store={store}&gt;&#10;        &lt;ThemeProvider theme={theme}&gt;&#10;          &lt;CssBaseline /&gt;&#10;          &lt;Router&gt;&#10;            &lt;AuthInitializer&gt;&#10;              &lt;AppRoutes /&gt;&#10;            &lt;/AuthInitializer&gt;&#10;          &lt;/Router&gt;&#10;        &lt;/ThemeProvider&gt;&#10;      &lt;/Provider&gt;&#10;    &lt;/QueryClientProvider&gt;&#10;  );&#10;}&#10;&#10;export default App;&#10;" />
              <option name="updatedContent" value="import React from 'react';&#10;import { Provider } from 'react-redux';&#10;import { ThemeProvider } from '@mui/material/styles';&#10;import { CssBaseline } from '@mui/material';&#10;import { QueryClient, QueryClientProvider } from '@tanstack/react-query';&#10;import { store } from './store/store';&#10;import theme from './theme';&#10;import AppRoutes from './routes/AppRoutes';&#10;import AuthInitializer from './components/AuthInitializer';&#10;&#10;const queryClient = new QueryClient();&#10;&#10;function App() {&#10;  return (&#10;    &lt;QueryClientProvider client={queryClient}&gt;&#10;      &lt;Provider store={store}&gt;&#10;        &lt;ThemeProvider theme={theme}&gt;&#10;          &lt;CssBaseline /&gt;&#10;          &lt;AuthInitializer&gt;&#10;            &lt;AppRoutes /&gt;&#10;          &lt;/AuthInitializer&gt;&#10;        &lt;/ThemeProvider&gt;&#10;      &lt;/Provider&gt;&#10;    &lt;/QueryClientProvider&gt;&#10;  );&#10;}&#10;&#10;export default App;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/components/Admin/Monitoring/UsageStats.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/components/Admin/Monitoring/UsageStats.tsx" />
              <option name="updatedContent" value="import React from 'react';&#10;import {&#10;  Box,&#10;  Typography,&#10;  Grid,&#10;  Paper,&#10;} from '@mui/material';&#10;import { PieChart, Pie, Cell, ResponsiveContainer, Legend, Tooltip } from 'recharts';&#10;import PhoneAndroidIcon from '@mui/icons-material/PhoneAndroid';&#10;import ComputerIcon from '@mui/icons-material/Computer';&#10;&#10;interface UsageStatsProps {&#10;  stats: {&#10;    mobile: number;&#10;    web: number;&#10;    totalUsers: number;&#10;  } | null;&#10;}&#10;&#10;const COLORS = ['#3f51b5', '#f50057'];&#10;&#10;const UsageStats: React.FC&lt;UsageStatsProps&gt; = ({ stats }) =&gt; {&#10;  if (!stats) return null;&#10;&#10;  const data = [&#10;    { name: 'Mobile', value: stats.mobile, icon: &lt;PhoneAndroidIcon /&gt; },&#10;    { name: 'Web', value: stats.web, icon: &lt;ComputerIcon /&gt; }&#10;  ];&#10;&#10;  const totalUsers = stats.mobile + stats.web;&#10;  const mobilePercentage = ((stats.mobile / totalUsers) * 100).toFixed(1);&#10;  const webPercentage = ((stats.web / totalUsers) * 100).toFixed(1);&#10;&#10;  return (&#10;    &lt;Box&gt;&#10;      &lt;Typography variant=&quot;h6&quot; gutterBottom&gt;&#10;        Statistiques d'Utilisation&#10;      &lt;/Typography&gt;&#10;&#10;      &lt;Grid container spacing={3}&gt;&#10;        &lt;Grid item xs={12}&gt;&#10;          &lt;ResponsiveContainer width=&quot;100%&quot; height={250}&gt;&#10;            &lt;PieChart&gt;&#10;              &lt;Pie&#10;                data={data}&#10;                cx=&quot;50%&quot;&#10;                cy=&quot;50%&quot;&#10;                labelLine={false}&#10;                outerRadius={80}&#10;                fill=&quot;#8884d8&quot;&#10;                dataKey=&quot;value&quot;&#10;              &gt;&#10;                {data.map((entry, index) =&gt; (&#10;                  &lt;Cell key={`cell-${index}`} fill={COLORS[index]} /&gt;&#10;                ))}&#10;              &lt;/Pie&gt;&#10;              &lt;Tooltip /&gt;&#10;              &lt;Legend /&gt;&#10;            &lt;/PieChart&gt;&#10;          &lt;/ResponsiveContainer&gt;&#10;        &lt;/Grid&gt;&#10;&#10;        &lt;Grid item xs={12}&gt;&#10;          &lt;Grid container spacing={2}&gt;&#10;            &lt;Grid item xs={6}&gt;&#10;              &lt;Paper sx={{ p: 2, textAlign: 'center' }}&gt;&#10;                &lt;PhoneAndroidIcon color=&quot;primary&quot; sx={{ fontSize: 40 }} /&gt;&#10;                &lt;Typography variant=&quot;h6&quot;&gt;&#10;                  {stats.mobile}&#10;                &lt;/Typography&gt;&#10;                &lt;Typography variant=&quot;body2&quot; color=&quot;textSecondary&quot;&gt;&#10;                  Utilisateurs Mobile ({mobilePercentage}%)&#10;                &lt;/Typography&gt;&#10;              &lt;/Paper&gt;&#10;            &lt;/Grid&gt;&#10;&#10;            &lt;Grid item xs={6}&gt;&#10;              &lt;Paper sx={{ p: 2, textAlign: 'center' }}&gt;&#10;                &lt;ComputerIcon sx={{ fontSize: 40, color: COLORS[1] }} /&gt;&#10;                &lt;Typography variant=&quot;h6&quot;&gt;&#10;                  {stats.web}&#10;                &lt;/Typography&gt;&#10;                &lt;Typography variant=&quot;body2&quot; color=&quot;textSecondary&quot;&gt;&#10;                  Utilisateurs Web ({webPercentage}%)&#10;                &lt;/Typography&gt;&#10;              &lt;/Paper&gt;&#10;            &lt;/Grid&gt;&#10;          &lt;/Grid&gt;&#10;        &lt;/Grid&gt;&#10;      &lt;/Grid&gt;&#10;    &lt;/Box&gt;&#10;  );&#10;};&#10;&#10;export default UsageStats;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/components/Admin/Reports/ReportGenerator.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/components/Admin/Reports/ReportGenerator.tsx" />
              <option name="originalContent" value="            variant=&quot;contained&quot;&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;          &gt;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;&#10;  const [selectedType, setSelectedType] = useState('');&#10;  const [format, setFormat] = useState('pdf');&#10;  TextField,&#10;&#10;  const [loading, setLoading] = useState(false);&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;        &lt;/Box&gt;&#10;  const [reportTypes, setReportTypes] = useState([]);&#10;  const [selectedType, setSelectedType] = useState('');&#10;    } catch (error) {&#10;          &gt;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;      &lt;/CardContent&gt;&#10;    &lt;/Card&gt;&#10;  );&#10;&#10;  const [loading, setLoading] = useState(false);&#10;  const [error, setError] = useState('');&#10;  const [success, setSuccess] = useState('');&#10;            disabled={loading}&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;            disabled={loading}&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;  const [selectedType, setSelectedType] = useState('');&#10;  const [selectedType, setSelectedType] = useState('');&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;    } catch (error) {&#10;export default ReportGenerator;&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;            onClick={handleGenerateReport}&#10;          &gt;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;            onClick={handleGenerateReport}&#10;    } catch (error) {&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;        &lt;/Box&gt;&#10;    } catch (error) {&#10;  const [loading, setLoading] = useState(false);&#10;  const [error, setError] = useState('');&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;          &lt;/Button&gt;&#10;&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;};&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;    } catch (error) {&#10;&#10;          &gt;&#10;&#10;            onClick={handleGenerateReport}&#10;    } catch (error) {&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;      &lt;/CardContent&gt;&#10;    &lt;/Card&gt;&#10;  );&#10;};&#10;&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;  const [success, setSuccess] = useState('');&#10;            disabled={loading}&#10;&#10;            variant=&quot;contained&quot;&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;            disabled={loading}&#10;    } catch (error) {&#10;&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;&#10;  const [loading, setLoading] = useState(false);&#10;  const [error, setError] = useState('');&#10;                {reportTypes.map((type) =&gt; (&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;    } catch (error) {&#10;export default ReportGenerator;&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;&#10;&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;};&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;const ReportGenerator = () =&gt; {&#10;  const [selectedType, setSelectedType] = useState('');&#10;  const [format, setFormat] = useState('pdf');&#10;  TextField,&#10;&#10;  const [loading, setLoading] = useState(false);&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;    } catch (error) {&#10;    } catch (error) {&#10;  const [loading, setLoading] = useState(false);&#10;  const [error, setError] = useState('');&#10;&#10;          &gt;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;      &lt;/CardContent&gt;&#10;    &lt;/Card&gt;&#10;  );&#10;};&#10;  const [loading, setLoading] = useState(false);&#10;  const [error, setError] = useState('');&#10;  const [success, setSuccess] = useState('');&#10;&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;        &lt;/Box&gt;&#10;const ReportGenerator = () =&gt; {&#10;    &lt;/Card&gt;&#10;  );&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;  TextField,&#10;&#10;&#10;            variant=&quot;contained&quot;&#10;&#10;  const [reportTypes, setReportTypes] = useState([]);&#10;&#10;&#10;        &lt;/Box&gt;&#10;const ReportGenerator = () =&gt; {&#10;  const [reportTypes, setReportTypes] = useState([]);&#10;  const [selectedType, setSelectedType] = useState('');&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;    } catch (error) {&#10;export default ReportGenerator;&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;          &gt;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;            onClick={handleGenerateReport}&#10;    } catch (error) {&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;      &lt;/CardContent&gt;&#10;    &lt;/Card&gt;&#10;&#10;const ReportGenerator = () =&gt; {&#10;    } catch (error) {&#10;  const [selectedType, setSelectedType] = useState('');&#10;  const [format, setFormat] = useState('pdf');&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;  const [loading, setLoading] = useState(false);&#10;  const [error, setError] = useState('');&#10;            disabled={loading}&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;          &lt;/Button&gt;&#10;&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;};&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;const ReportGenerator = () =&gt; {&#10;&#10;  const [success, setSuccess] = useState('');&#10;&#10;          &gt;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;const ReportGenerator = () =&gt; {&#10;  const [reportTypes, setReportTypes] = useState([]);&#10;  const [selectedType, setSelectedType] = useState('');&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;    } catch (error) {&#10;export default ReportGenerator;&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;          &gt;&#10;&#10;            onClick={handleGenerateReport}&#10;    } catch (error) {&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;      &lt;/CardContent&gt;&#10;    &lt;/Card&gt;&#10;  );&#10;};&#10;&#10;  const [loading, setLoading] = useState(false);&#10;  const [error, setError] = useState('');&#10;  const [success, setSuccess] = useState('');&#10;            disabled={loading}&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;const ReportGenerator = () =&gt; {&#10;  const [reportTypes, setReportTypes] = useState([]);&#10;&#10;            disabled={loading}&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;      &lt;/CardContent&gt;&#10;    &lt;/Card&gt;&#10;  );&#10;};&#10;  TextField,&#10;&#10;&#10;            variant=&quot;contained&quot;&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;&#10;            disabled={loading}&#10;          &gt;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;&#10;  const [loading, setLoading] = useState(false);&#10;&#10;  const [success, setSuccess] = useState('');&#10;            disabled={loading}&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;          &lt;/Button&gt;&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;};&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;&#10;  const [selectedType, setSelectedType] = useState('');&#10;  const [format, setFormat] = useState('pdf');&#10;  TextField,&#10;&#10;  const [loading, setLoading] = useState(false);&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;        &lt;/Box&gt;&#10;const ReportGenerator = () =&gt; {&#10;  const [reportTypes, setReportTypes] = useState([]);&#10;  const [selectedType, setSelectedType] = useState('');&#10;    } catch (error) {&#10;          &gt;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;      &lt;/CardContent&gt;&#10;    &lt;/Card&gt;&#10;  );&#10;};&#10;  const [loading, setLoading] = useState(false);&#10;  const [error, setError] = useState('');&#10;  const [success, setSuccess] = useState('');&#10;            disabled={loading}&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;        &lt;/Box&gt;&#10;    } catch (error) {&#10;    &lt;/Card&gt;&#10;  );&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;  TextField,&#10;&#10;&#10;            variant=&quot;contained&quot;&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;  const [selectedType, setSelectedType] = useState('');&#10;  const [selectedType, setSelectedType] = useState('');&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;    } catch (error) {&#10;export default ReportGenerator;&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;            onClick={handleGenerateReport}&#10;          &gt;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;            onClick={handleGenerateReport}&#10;    } catch (error) {&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;        &lt;/Box&gt;&#10;      &lt;/CardContent&gt;&#10;  const [loading, setLoading] = useState(false);&#10;  const [error, setError] = useState('');&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;          &lt;/Button&gt;&#10;&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;};&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;const ReportGenerator = () =&gt; {&#10;&#10;  const [success, setSuccess] = useState('');&#10;&#10;&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;          &gt;&#10;&#10;            onClick={handleGenerateReport}&#10;    } catch (error) {&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;      &lt;/CardContent&gt;&#10;    &lt;/Card&gt;&#10;  );&#10;};&#10;&#10;  const [loading, setLoading] = useState(false);&#10;  const [error, setError] = useState('');&#10;  const [success, setSuccess] = useState('');&#10;            disabled={loading}&#10;    } catch (error) {&#10;&#10;      &lt;/CardContent&gt;&#10;    &lt;/Card&gt;&#10;  );&#10;};&#10;  TextField,&#10;&#10;&#10;            variant=&quot;contained&quot;&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;    } catch (error) {&#10;&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;&#10;  const [loading, setLoading] = useState(false);&#10;  const [error, setError] = useState('');&#10;                {reportTypes.map((type) =&gt; (&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;    } catch (error) {&#10;export default ReportGenerator;&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;&#10;&#10;  const [loading, setLoading] = useState(false);&#10;&#10;  const [success, setSuccess] = useState('');&#10;            disabled={loading}&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;};&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;const ReportGenerator = () =&gt; {&#10;  const [selectedType, setSelectedType] = useState('');&#10;  const [format, setFormat] = useState('pdf');&#10;  TextField,&#10;&#10;  const [loading, setLoading] = useState(false);&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;    } catch (error) {&#10;    } catch (error) {&#10;  const [loading, setLoading] = useState(false);&#10;  const [error, setError] = useState('');&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;  const [success, setSuccess] = useState('');&#10;            disabled={loading}&#10;          &gt;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;const ReportGenerator = () =&gt; {&#10;  const [reportTypes, setReportTypes] = useState([]);&#10;  const [selectedType, setSelectedType] = useState('');&#10;    } catch (error) {&#10;          &gt;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;      &lt;/CardContent&gt;&#10;    &lt;/Card&gt;&#10;  );&#10;};&#10;  const [loading, setLoading] = useState(false);&#10;  const [error, setError] = useState('');&#10;  const [success, setSuccess] = useState('');&#10;            disabled={loading}&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;        &lt;/Box&gt;&#10;const ReportGenerator = () =&gt; {&#10;    &lt;/Card&gt;&#10;  );&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;  TextField,&#10;&#10;&#10;            variant=&quot;contained&quot;&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;&#10;          &gt;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;const ReportGenerator = () =&gt; {&#10;  const [reportTypes, setReportTypes] = useState([]);&#10;  const [selectedType, setSelectedType] = useState('');&#10;&#10;        &lt;/Box&gt;&#10;const ReportGenerator = () =&gt; {&#10;  const [reportTypes, setReportTypes] = useState([]);&#10;  const [selectedType, setSelectedType] = useState('');&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;    } catch (error) {&#10;export default ReportGenerator;&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;          &gt;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;            onClick={handleGenerateReport}&#10;    } catch (error) {&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;      &lt;/CardContent&gt;&#10;    &lt;/Card&gt;&#10;&#10;const ReportGenerator = () =&gt; {&#10;    } catch (error) {&#10;  const [selectedType, setSelectedType] = useState('');&#10;  const [format, setFormat] = useState('pdf');&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;  const [loading, setLoading] = useState(false);&#10;  const [error, setError] = useState('');&#10;            disabled={loading}&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;          &lt;/Button&gt;&#10;&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;};&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;const ReportGenerator = () =&gt; {&#10;&#10;  const [success, setSuccess] = useState('');&#10;&#10;          &gt;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;const ReportGenerator = () =&gt; {&#10;  const [reportTypes, setReportTypes] = useState([]);&#10;  const [selectedType, setSelectedType] = useState('');&#10;    } catch (error) {&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;    } catch (error) {&#10;export default ReportGenerator;&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;          &gt;&#10;&#10;            onClick={handleGenerateReport}&#10;    } catch (error) {&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;      &lt;/CardContent&gt;&#10;    &lt;/Card&gt;&#10;  );&#10;};&#10;&#10;  const [loading, setLoading] = useState(false);&#10;  const [error, setError] = useState('');&#10;  const [success, setSuccess] = useState('');&#10;            disabled={loading}&#10;    } catch (error) {&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;const ReportGenerator = () =&gt; {&#10;  const [reportTypes, setReportTypes] = useState([]);&#10;&#10;            disabled={loading}&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;      &lt;/CardContent&gt;&#10;    &lt;/Card&gt;&#10;  );&#10;};&#10;  TextField,&#10;&#10;&#10;import React, { useState, useEffect } from 'react';&#10;import {&#10;  Box,&#10;    } catch (error) {&#10;  Card,&#10;  CardContent,&#10;  FormControl,&#10;&#10;import reportService from '../../../services/reportService';&#10;import { fr } from 'date-fns/locale';&#10;&#10;&#10;    loadReportTypes();&#10;&#10;&#10;  const loadReportTypes = async () =&gt; {&#10;    try {&#10;      const types = await reportService.getReportTypes();&#10;      setReportTypes(types);&#10;&#10;    setLoading(true);&#10;    setError('');&#10;    setSuccess('');&#10;&#10;    try {&#10;      const response = await reportService.generateReport({&#10;        type: selectedType,&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;        dateDebut: dateDebut?.toISOString(),&#10;    } catch (error) {&#10;      });&#10;&#10;      const blob = await reportService.downloadReport(response.data.reportUrl);&#10;      const url = window.URL.createObjectURL(blob);&#10;      const a = document.createElement('a');&#10;      a.href = url;&#10;      a.download = response.data.filename;&#10;      document.body.appendChild(a);&#10;      a.click();&#10;      a.remove();&#10;      window.URL.revokeObjectURL(url);&#10;&#10;      setSuccess('Rapport généré avec succès');&#10;&#10;          Générateur de Rapports&#10;&#10;                onChange={(e) =&gt; setSelectedType(e.target.value)}&#10;&#10;              &gt;&#10;                onChange={(e) =&gt; setFormat(e.target.value)}&#10;                  &lt;MenuItem key={type.id} value={type.id}&gt;&#10;                    {type.name}&#10;                  &lt;/MenuItem&gt;&#10;                ))}&#10;              &lt;/Select&gt;&#10;            &lt;/FormControl&gt;&#10;          &lt;/Grid&gt;&#10;&#10;          &lt;Grid item xs={12} md={6}&gt;&#10;&#10;          &lt;/Grid&gt;&#10;&#10;          &lt;Grid item xs={12} md={6}&gt;&#10;            &lt;LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={fr}&gt;&#10;              &lt;DatePicker&#10;                label=&quot;Date de début&quot;&#10;                value={dateDebut}&#10;                onChange={(newValue) =&gt; setDateDebut(newValue)}&#10;                slotProps={{&#10;                  textField: {&#10;                    fullWidth: true,&#10;                  },&#10;                }}&#10;              /&gt;&#10;            &lt;/LocalizationProvider&gt;&#10;          &lt;/Grid&gt;&#10;&#10;          &lt;Grid item xs={12} md={6}&gt;&#10;            &lt;LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={fr}&gt;&#10;              &lt;DatePicker&#10;                label=&quot;Date de fin&quot;&#10;&#10;&#10;&#10;          &lt;Button&#10;&#10;&#10;" />
              <option name="updatedContent" value="import React, { useState, useEffect } from 'react';&#10;import {&#10;  Box,&#10;  Button,&#10;  Card,&#10;  CardContent,&#10;  FormControl,&#10;  Grid,&#10;  InputLabel,&#10;  MenuItem,&#10;  Select,&#10;  Typography,&#10;  Alert,&#10;} from '@mui/material';&#10;import { LocalizationProvider } from '@mui/x-date-pickers/LocalizationProvider';&#10;import { DatePicker } from '@mui/x-date-pickers/DatePicker';&#10;import { AdapterDateFns } from '@mui/x-date-pickers/AdapterDateFns';&#10;import reportService from '../../../services/reportService';&#10;import { fr } from 'date-fns/locale';&#10;&#10;const ReportGenerator: React.FC = () =&gt; {&#10;  const [reportTypes, setReportTypes] = useState&lt;any[]&gt;([]);&#10;  const [selectedType, setSelectedType] = useState&lt;string&gt;('');&#10;  const [format, setFormat] = useState&lt;string&gt;('pdf');&#10;  const [dateDebut, setDateDebut] = useState&lt;Date | null&gt;(null);&#10;  const [dateFin, setDateFin] = useState&lt;Date | null&gt;(null);&#10;  const [loading, setLoading] = useState&lt;boolean&gt;(false);&#10;  const [error, setError] = useState&lt;string&gt;('');&#10;  const [success, setSuccess] = useState&lt;string&gt;('');&#10;&#10;  useEffect(() =&gt; {&#10;    loadReportTypes();&#10;  }, []);&#10;&#10;  const loadReportTypes = async () =&gt; {&#10;    try {&#10;      const types = await reportService.getReportTypes();&#10;      setReportTypes(types);&#10;    } catch (err) {&#10;      setError('Erreur lors du chargement des types de rapports');&#10;    }&#10;  };&#10;&#10;  const handleGenerateReport = async () =&gt; {&#10;    if (!selectedType || !format) {&#10;      setError('Veuillez sélectionner un type de rapport et un format');&#10;      return;&#10;    }&#10;&#10;    setLoading(true);&#10;    setError('');&#10;    setSuccess('');&#10;&#10;    try {&#10;      const response = await reportService.generateReport({&#10;        type: selectedType,&#10;        format,&#10;        dateDebut: dateDebut?.toISOString(),&#10;        dateFin: dateFin?.toISOString(),&#10;      });&#10;&#10;      const blob = await reportService.downloadReport(response.data.reportUrl);&#10;      const url = window.URL.createObjectURL(blob);&#10;      const a = document.createElement('a');&#10;      a.href = url;&#10;      a.download = response.data.filename;&#10;      document.body.appendChild(a);&#10;      a.click();&#10;      a.remove();&#10;      window.URL.revokeObjectURL(url);&#10;&#10;      setSuccess('Rapport généré avec succès');&#10;    } catch (err) {&#10;      setError('Erreur lors de la génération du rapport');&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;Card&gt;&#10;      &lt;CardContent&gt;&#10;        &lt;Typography variant=&quot;h6&quot; gutterBottom&gt;&#10;          Générateur de Rapports&#10;        &lt;/Typography&gt;&#10;&#10;        {error &amp;&amp; &lt;Alert severity=&quot;error&quot; sx={{ mb: 2 }}&gt;{error}&lt;/Alert&gt;}&#10;        {success &amp;&amp; &lt;Alert severity=&quot;success&quot; sx={{ mb: 2 }}&gt;{success}&lt;/Alert&gt;}&#10;&#10;        &lt;Grid container spacing={3}&gt;&#10;          &lt;Grid item xs={12} md={6}&gt;&#10;            &lt;FormControl fullWidth&gt;&#10;              &lt;InputLabel&gt;Type de Rapport&lt;/InputLabel&gt;&#10;              &lt;Select&#10;                value={selectedType}&#10;                onChange={(e) =&gt; setSelectedType(e.target.value as string)}&#10;                label=&quot;Type de Rapport&quot;&#10;              &gt;&#10;                {reportTypes.map((type: any) =&gt; (&#10;                  &lt;MenuItem key={type.id} value={type.id}&gt;&#10;                    {type.name}&#10;                  &lt;/MenuItem&gt;&#10;                ))}&#10;              &lt;/Select&gt;&#10;            &lt;/FormControl&gt;&#10;          &lt;/Grid&gt;&#10;&#10;          &lt;Grid item xs={12} md={6}&gt;&#10;            &lt;FormControl fullWidth&gt;&#10;              &lt;InputLabel&gt;Format&lt;/InputLabel&gt;&#10;              &lt;Select&#10;                value={format}&#10;                onChange={(e) =&gt; setFormat(e.target.value as string)}&#10;                label=&quot;Format&quot;&#10;              &gt;&#10;                &lt;MenuItem value=&quot;pdf&quot;&gt;PDF&lt;/MenuItem&gt;&#10;                &lt;MenuItem value=&quot;xlsx&quot;&gt;Excel&lt;/MenuItem&gt;&#10;              &lt;/Select&gt;&#10;            &lt;/FormControl&gt;&#10;          &lt;/Grid&gt;&#10;&#10;          &lt;Grid item xs={12} md={6}&gt;&#10;            &lt;LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={fr}&gt;&#10;              &lt;DatePicker&#10;                label=&quot;Date de début&quot;&#10;                value={dateDebut}&#10;                onChange={(newValue) =&gt; setDateDebut(newValue)}&#10;                slotProps={{&#10;                  textField: {&#10;                    fullWidth: true,&#10;                  },&#10;                }}&#10;              /&gt;&#10;            &lt;/LocalizationProvider&gt;&#10;          &lt;/Grid&gt;&#10;&#10;          &lt;Grid item xs={12} md={6}&gt;&#10;            &lt;LocalizationProvider dateAdapter={AdapterDateFns} adapterLocale={fr}&gt;&#10;              &lt;DatePicker&#10;                label=&quot;Date de fin&quot;&#10;                value={dateFin}&#10;                onChange={(newValue) =&gt; setDateFin(newValue)}&#10;                slotProps={{&#10;                  textField: {&#10;                    fullWidth: true,&#10;                  },&#10;                }}&#10;              /&gt;&#10;            &lt;/LocalizationProvider&gt;&#10;          &lt;/Grid&gt;&#10;        &lt;/Grid&gt;&#10;&#10;        &lt;Box sx={{ mt: 3, display: 'flex', justifyContent: 'flex-end' }}&gt;&#10;          &lt;Button&#10;            variant=&quot;contained&quot;&#10;            onClick={handleGenerateReport}&#10;            disabled={loading}&#10;          &gt;&#10;            {loading ? 'Génération...' : 'Générer le rapport'}&#10;          &lt;/Button&gt;&#10;        &lt;/Box&gt;&#10;      &lt;/CardContent&gt;&#10;    &lt;/Card&gt;&#10;  );&#10;};&#10;&#10;export default ReportGenerator;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/components/AuthInitializer.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/components/AuthInitializer.tsx" />
              <option name="originalContent" value="import React, { useEffect, useState } from 'react';&#10;import { useAuth } from '../hooks/useAuth';&#10;import { getStoredToken, getCurrentUser, setAuthToken } from '../services/authService';&#10;&#10;interface AuthInitializerProps {&#10;  children: React.ReactNode;&#10;}&#10;&#10;const AuthInitializer: React.FC&lt;AuthInitializerProps&gt; = ({ children }) =&gt; {&#10;  const [isInitialized, setIsInitialized] = useState(false);&#10;  const { setUser } = useAuth();&#10;&#10;  useEffect(() =&gt; {&#10;    const initializeAuth = async () =&gt; {&#10;      try {&#10;        const token = getStoredToken();&#10;        if (token) {&#10;          setAuthToken(token);&#10;          const user = await getCurrentUser();&#10;          setUser(user);&#10;        }&#10;      } catch (error) {&#10;        console.error('Auth initialization failed:', error);&#10;      } finally {&#10;        setIsInitialized(true);&#10;      }&#10;    };&#10;&#10;    initializeAuth();&#10;  }, [setUser]);&#10;&#10;  if (!isInitialized) {&#10;    return null; // or a loading spinner&#10;  }&#10;&#10;  return &lt;&gt;{children}&lt;/&gt;;&#10;};&#10;&#10;export default AuthInitializer;&#10;" />
              <option name="updatedContent" value="import React, { useEffect } from 'react';&#10;import { useAuth } from '../hooks/useAuth';&#10;import { getStoredToken, getCurrentUser, setAuthToken } from '../services/authService';&#10;&#10;interface AuthInitializerProps {&#10;  children: React.ReactNode;&#10;}&#10;&#10;const AuthInitializer: React.FC&lt;AuthInitializerProps&gt; = ({ children }) =&gt; {&#10;  const { setUser } = useAuth();&#10;&#10;  useEffect(() =&gt; {&#10;    const initializeAuth = async () =&gt; {&#10;      try {&#10;        const token = getStoredToken();&#10;        if (token) {&#10;          setAuthToken(token);&#10;          const user = await getCurrentUser();&#10;          setUser(user);&#10;        }&#10;      } catch (error) {&#10;        console.error('Auth initialization failed:', error);&#10;      }&#10;    };&#10;&#10;    initializeAuth();&#10;  }, [setUser]);&#10;&#10;  // Afficher directement le contenu sans attendre&#10;  return &lt;&gt;{children}&lt;/&gt;;&#10;};&#10;&#10;export default AuthInitializer;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/components/Documents/DocumentsGallery.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/components/Documents/DocumentsGallery.tsx" />
              <option name="updatedContent" value="import React, { useState, useEffect } from 'react';&#10;import {&#10;  Box,&#10;  Grid,&#10;  Paper,&#10;  Typography,&#10;  Button,&#10;  Chip,&#10;  IconButton,&#10;  Dialog,&#10;  DialogTitle,&#10;  DialogContent,&#10;  CircularProgress&#10;} from '@mui/material';&#10;import CloudUploadIcon from '@mui/icons-material/CloudUpload';&#10;import VisibilityIcon from '@mui/icons-material/Visibility';&#10;import { useDropzone } from 'react-dropzone';&#10;&#10;interface Document {&#10;  id: string;&#10;  type: string;&#10;  required: boolean;&#10;  dueDate: string;&#10;  status: 'RECEIVED' | 'WAITING' | 'EXPIRED' | 'UPDATE_REQUIRED';&#10;  files: Array&lt;{ name: string; url: string }&gt;;&#10;  uploadedAt?: string;&#10;  validatedBy?: string;&#10;}&#10;&#10;const statusColors = {&#10;  RECEIVED: 'success',&#10;  WAITING: 'warning',&#10;  EXPIRED: 'error',&#10;  UPDATE_REQUIRED: 'error'&#10;};&#10;&#10;const statusLabels = {&#10;  RECEIVED: 'Reçu',&#10;  WAITING: 'En attente',&#10;  EXPIRED: 'Expiré',&#10;  UPDATE_REQUIRED: 'Mise à jour requise'&#10;};&#10;&#10;const DocumentsGallery: React.FC = () =&gt; {&#10;  const [documents, setDocuments] = useState&lt;Document[]&gt;([]);&#10;  const [loading, setLoading] = useState(true);&#10;  const [selectedDoc, setSelectedDoc] = useState&lt;Document | null&gt;(null);&#10;  const [uploadDialogOpen, setUploadDialogOpen] = useState(false);&#10;&#10;  useEffect(() =&gt; {&#10;    const loadDocuments = async () =&gt; {&#10;      try {&#10;        // TODO: Replace with actual API call&#10;        const response = await fetch('/api/documents');&#10;        const data = await response.json();&#10;        setDocuments(data);&#10;      } catch (error) {&#10;        console.error('Error loading documents:', error);&#10;      } finally {&#10;        setLoading(false);&#10;      }&#10;    };&#10;    &#10;    loadDocuments();&#10;  }, []);&#10;&#10;  const { getRootProps, getInputProps, isDragActive } = useDropzone({&#10;    onDrop: (acceptedFiles) =&gt; {&#10;      // Handle file upload&#10;      console.log(acceptedFiles);&#10;    }&#10;  });&#10;&#10;  if (loading) {&#10;    return &lt;CircularProgress /&gt;;&#10;  }&#10;&#10;  return (&#10;    &lt;Box sx={{ p: 3 }}&gt;&#10;      &lt;Grid container spacing={3}&gt;&#10;        {documents.map((doc) =&gt; (&#10;          &lt;Grid item xs={12} sm={6} md={4} key={doc.id}&gt;&#10;            &lt;Paper sx={{ p: 2 }}&gt;&#10;              &lt;Box sx={{ display: 'flex', justifyContent: 'space-between', mb: 2 }}&gt;&#10;                &lt;Typography variant=&quot;h6&quot;&gt;{doc.type}&lt;/Typography&gt;&#10;                &lt;Chip&#10;                  label={statusLabels[doc.status]}&#10;                  color={statusColors[doc.status] as any}&#10;                  size=&quot;small&quot;&#10;                /&gt;&#10;              &lt;/Box&gt;&#10;&#10;              &lt;Box sx={{ display: 'flex', gap: 1, mt: 2 }}&gt;&#10;                &lt;Button&#10;                  variant=&quot;contained&quot;&#10;                  startIcon={&lt;CloudUploadIcon /&gt;}&#10;                  onClick={() =&gt; {&#10;                    setSelectedDoc(doc);&#10;                    setUploadDialogOpen(true);&#10;                  }}&#10;                &gt;&#10;                  Upload&#10;                &lt;/Button&gt;&#10;                {doc.files.length &gt; 0 &amp;&amp; (&#10;                  &lt;IconButton&#10;                    onClick={() =&gt; {/* Handle view */}}&#10;                  &gt;&#10;                    &lt;VisibilityIcon /&gt;&#10;                  &lt;/IconButton&gt;&#10;                )}&#10;              &lt;/Box&gt;&#10;&#10;              {doc.dueDate &amp;&amp; (&#10;                &lt;Typography variant=&quot;caption&quot; display=&quot;block&quot; sx={{ mt: 1 }}&gt;&#10;                  Date limite: {new Date(doc.dueDate).toLocaleDateString()}&#10;                &lt;/Typography&gt;&#10;              )}&#10;            &lt;/Paper&gt;&#10;          &lt;/Grid&gt;&#10;        ))}&#10;      &lt;/Grid&gt;&#10;&#10;      &lt;Dialog&#10;        open={uploadDialogOpen}&#10;        onClose={() =&gt; setUploadDialogOpen(false)}&#10;        maxWidth=&quot;sm&quot;&#10;        fullWidth&#10;      &gt;&#10;        &lt;DialogTitle&gt;&#10;          Upload Document: {selectedDoc?.type}&#10;        &lt;/DialogTitle&gt;&#10;        &lt;DialogContent&gt;&#10;          &lt;Box&#10;            {...getRootProps()}&#10;            sx={{&#10;              border: '2px dashed #ccc',&#10;              borderRadius: 2,&#10;              p: 3,&#10;              textAlign: 'center',&#10;              cursor: 'pointer',&#10;              '&amp;:hover': {&#10;                borderColor: 'primary.main'&#10;              }&#10;            }}&#10;          &gt;&#10;            &lt;input {...getInputProps()} /&gt;&#10;            {isDragActive ? (&#10;              &lt;Typography&gt;Déposez les fichiers ici...&lt;/Typography&gt;&#10;            ) : (&#10;              &lt;Typography&gt;&#10;                Glissez-déposez des fichiers ici, ou cliquez pour sélectionner&#10;              &lt;/Typography&gt;&#10;            )}&#10;          &lt;/Box&gt;&#10;        &lt;/DialogContent&gt;&#10;      &lt;/Dialog&gt;&#10;    &lt;/Box&gt;&#10;  );&#10;};&#10;&#10;export default DocumentsGallery;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/components/EntrepriseDashboard/ChartWrapper.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/components/EntrepriseDashboard/ChartWrapper.tsx" />
              <option name="updatedContent" value="import React from 'react';&#10;import { Paper, Typography, Box } from '@mui/material';&#10;import {&#10;  LineChart,&#10;  Line,&#10;  XAxis,&#10;  YAxis,&#10;  CartesianGrid,&#10;  Tooltip,&#10;  Legend,&#10;  ResponsiveContainer&#10;} from 'recharts';&#10;&#10;interface ChartWrapperProps {&#10;  title: string;&#10;  data: Array&lt;{&#10;    date: string;&#10;    value: number;&#10;    indicator: string;&#10;    unit?: string;&#10;  }&gt;;&#10;}&#10;&#10;const ChartWrapper: React.FC&lt;ChartWrapperProps&gt; = ({ title, data }) =&gt; {&#10;  // Group data by indicator&#10;  const indicators = Array.from(new Set(data.map(item =&gt; item.indicator)));&#10;  &#10;  // Transform data for Recharts&#10;  const transformedData = data.reduce((acc: any[], curr) =&gt; {&#10;    const dateExists = acc.find(item =&gt; item.date === curr.date);&#10;    if (dateExists) {&#10;      dateExists[curr.indicator] = curr.value;&#10;    } else {&#10;      const newEntry = { date: curr.date };&#10;      newEntry[curr.indicator] = curr.value;&#10;      acc.push(newEntry);&#10;    }&#10;    return acc;&#10;  }, []);&#10;&#10;  // Colors for different indicators&#10;  const colors = ['#2196f3', '#4caf50', '#ff9800', '#f44336'];&#10;&#10;  // Custom tooltip formatter&#10;  const CustomTooltip = ({ active, payload, label }: any) =&gt; {&#10;    if (active &amp;&amp; payload &amp;&amp; payload.length) {&#10;      return (&#10;        &lt;Paper sx={{ p: 2 }}&gt;&#10;          &lt;Typography variant=&quot;subtitle2&quot; color=&quot;textSecondary&quot;&gt;&#10;            {label}&#10;          &lt;/Typography&gt;&#10;          {payload.map((entry: any, index: number) =&gt; (&#10;            &lt;Typography key={index} style={{ color: entry.color }}&gt;&#10;              {entry.name}: {entry.value.toLocaleString('fr-FR')}&#10;              {data.find(d =&gt; d.indicator === entry.name)?.unit || ''}&#10;            &lt;/Typography&gt;&#10;          ))}&#10;        &lt;/Paper&gt;&#10;      );&#10;    }&#10;    return null;&#10;  };&#10;&#10;  return (&#10;    &lt;Paper sx={{ p: 2, height: '400px' }}&gt;&#10;      &lt;Typography variant=&quot;h6&quot; gutterBottom&gt;&#10;        {title}&#10;      &lt;/Typography&gt;&#10;      &lt;ResponsiveContainer width=&quot;100%&quot; height=&quot;90%&quot;&gt;&#10;        &lt;LineChart data={transformedData}&gt;&#10;          &lt;CartesianGrid strokeDasharray=&quot;3 3&quot; /&gt;&#10;          &lt;XAxis &#10;            dataKey=&quot;date&quot; &#10;            tick={{ fontSize: 12 }}&#10;            interval=&quot;preserveStartEnd&quot;&#10;          /&gt;&#10;          &lt;YAxis &#10;            tick={{ fontSize: 12 }}&#10;            tickFormatter={(value) =&gt; value.toLocaleString('fr-FR')}&#10;          /&gt;&#10;          &lt;Tooltip content={&lt;CustomTooltip /&gt;} /&gt;&#10;          &lt;Legend /&gt;&#10;          {indicators.map((indicator, index) =&gt; (&#10;            &lt;Line&#10;              key={indicator}&#10;              type=&quot;monotone&quot;&#10;              dataKey={indicator}&#10;              stroke={colors[index % colors.length]}&#10;              strokeWidth={2}&#10;              dot={{ r: 4 }}&#10;              activeDot={{ r: 6 }}&#10;            /&gt;&#10;          ))}&#10;        &lt;/LineChart&gt;&#10;      &lt;/ResponsiveContainer&gt;&#10;    &lt;/Paper&gt;&#10;  );&#10;};&#10;&#10;export default ChartWrapper;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/components/EntrepriseDashboard/DocumentUploader.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/components/EntrepriseDashboard/DocumentUploader.tsx" />
              <option name="originalContent" value="import React, { useState } from 'react';&#10;import { Box, Button, LinearProgress, Typography } from '@mui/material';&#10;    setProgress(100);&#10;const DocumentUploader: React.FC = () =&gt; {&#10;  const [file, setFile] = useState&lt;File | null&gt;(null);&#10;  const [progress, setProgress] = useState&lt;number | null&gt;(null);&#10;" />
              <option name="updatedContent" value="import React, { useState, useCallback } from 'react';&#10;import {&#10;  Box,&#10;  Typography,&#10;  Button,&#10;  LinearProgress,&#10;  Paper,&#10;  Select,&#10;  MenuItem,&#10;  FormControl,&#10;  InputLabel,&#10;  Alert&#10;} from '@mui/material';&#10;import { useDropzone } from 'react-dropzone';&#10;import CloudUploadIcon from '@mui/icons-material/CloudUpload';&#10;import documentService from '../../services/documentService';&#10;import { useAuth } from '../../hooks/useAuth';&#10;&#10;interface DocumentUploaderProps {&#10;  onUploadComplete?: () =&gt; void;&#10;}&#10;&#10;const ACCEPTED_FILE_TYPES = {&#10;  'application/pdf': ['.pdf'],&#10;  'image/jpeg': ['.jpg', '.jpeg'],&#10;  'image/png': ['.png']&#10;};&#10;&#10;const DocumentUploader: React.FC&lt;DocumentUploaderProps&gt; = ({ onUploadComplete }) =&gt; {&#10;  const [uploading, setUploading] = useState(false);&#10;  const [progress, setProgress] = useState(0);&#10;  const [error, setError] = useState&lt;string | null&gt;(null);&#10;  const [documentType, setDocumentType] = useState('');&#10;  const { user } = useAuth();&#10;&#10;  const onDrop = useCallback(async (acceptedFiles: File[]) =&gt; {&#10;    if (!documentType) {&#10;      setError('Veuillez sélectionner un type de document');&#10;      return;&#10;    }&#10;&#10;    const file = acceptedFiles[0];&#10;    if (!file) return;&#10;&#10;    setUploading(true);&#10;    setError(null);&#10;    &#10;    try {&#10;      if (user?.entrepriseId) {&#10;        await documentService.uploadDocument(user.entrepriseId, documentType, file);&#10;        setProgress(100);&#10;        if (onUploadComplete) {&#10;          onUploadComplete();&#10;        }&#10;      }&#10;    } catch (err: any) {&#10;      setError(err.message || 'Une erreur est survenue lors du téléchargement');&#10;    } finally {&#10;      setUploading(false);&#10;    }&#10;  }, [documentType, user, onUploadComplete]);&#10;&#10;  const { getRootProps, getInputProps, isDragActive } = useDropzone({&#10;    onDrop,&#10;    accept: ACCEPTED_FILE_TYPES,&#10;    multiple: false&#10;  });&#10;&#10;  return (&#10;    &lt;Box sx={{ p: 2 }}&gt;&#10;      &lt;FormControl fullWidth sx={{ mb: 3 }}&gt;&#10;        &lt;InputLabel&gt;Type de document&lt;/InputLabel&gt;&#10;        &lt;Select&#10;          value={documentType}&#10;          label=&quot;Type de document&quot;&#10;          onChange={(e) =&gt; setDocumentType(e.target.value)}&#10;        &gt;&#10;          &lt;MenuItem value=&quot;BUSINESS_PLAN&quot;&gt;Business Plan&lt;/MenuItem&gt;&#10;          &lt;MenuItem value=&quot;FINANCIAL_STATEMENT&quot;&gt;État Financier&lt;/MenuItem&gt;&#10;          &lt;MenuItem value=&quot;TAX_CERTIFICATE&quot;&gt;Attestation Fiscale&lt;/MenuItem&gt;&#10;          &lt;MenuItem value=&quot;SOCIAL_SECURITY&quot;&gt;Sécurité Sociale&lt;/MenuItem&gt;&#10;          &lt;MenuItem value=&quot;TRADE_REGISTER&quot;&gt;Registre du Commerce&lt;/MenuItem&gt;&#10;        &lt;/Select&gt;&#10;      &lt;/FormControl&gt;&#10;&#10;      &lt;Paper&#10;        {...getRootProps()}&#10;        sx={{&#10;          p: 3,&#10;          textAlign: 'center',&#10;          backgroundColor: isDragActive ? 'action.hover' : 'background.paper',&#10;          border: '2px dashed',&#10;          borderColor: isDragActive ? 'primary.main' : 'divider',&#10;          cursor: 'pointer'&#10;        }}&#10;      &gt;&#10;        &lt;input {...getInputProps()} /&gt;&#10;        &lt;CloudUploadIcon sx={{ fontSize: 48, color: 'primary.main', mb: 2 }} /&gt;&#10;        &lt;Typography variant=&quot;h6&quot; gutterBottom&gt;&#10;          {isDragActive ? &#10;            'Déposez le fichier ici' : &#10;            'Glissez et déposez un fichier ou cliquez pour sélectionner'&#10;          }&#10;        &lt;/Typography&gt;&#10;        &lt;Typography variant=&quot;body2&quot; color=&quot;text.secondary&quot;&gt;&#10;          Formats acceptés: PDF, JPG, PNG&#10;        &lt;/Typography&gt;&#10;      &lt;/Paper&gt;&#10;&#10;      {uploading &amp;&amp; (&#10;        &lt;Box sx={{ mt: 2 }}&gt;&#10;          &lt;LinearProgress variant=&quot;determinate&quot; value={progress} /&gt;&#10;          &lt;Typography variant=&quot;body2&quot; color=&quot;text.secondary&quot; align=&quot;center&quot; sx={{ mt: 1 }}&gt;&#10;            {progress}% téléchargé&#10;          &lt;/Typography&gt;&#10;        &lt;/Box&gt;&#10;      )}&#10;&#10;      {error &amp;&amp; (&#10;        &lt;Alert severity=&quot;error&quot; sx={{ mt: 2 }}&gt;&#10;          {error}&#10;        &lt;/Alert&gt;&#10;      )}&#10;    &lt;/Box&gt;&#10;  );&#10;};&#10;&#10;export default DocumentUploader;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/components/EntrepriseDashboard/KPIWidget.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/components/EntrepriseDashboard/KPIWidget.tsx" />
              <option name="updatedContent" value="import React from 'react';&#10;import { Paper, Typography, Box } from '@mui/material';&#10;import TrendingUpIcon from '@mui/icons-material/TrendingUp';&#10;import TrendingDownIcon from '@mui/icons-material/TrendingDown';&#10;import { styled } from '@mui/material/styles';&#10;&#10;interface KPIWidgetProps {&#10;  title: string;&#10;  value: string;&#10;  trend?: {&#10;    value: number;&#10;    direction: 'up' | 'down';&#10;  };&#10;  icon?: React.ReactNode;&#10;}&#10;&#10;const WidgetPaper = styled(Paper)(({ theme }) =&gt; ({&#10;  padding: theme.spacing(2),&#10;  height: '100%',&#10;  display: 'flex',&#10;  flexDirection: 'column',&#10;  transition: 'transform 0.2s ease-in-out',&#10;  '&amp;:hover': {&#10;    transform: 'translateY(-4px)',&#10;    boxShadow: theme.shadows[4]&#10;  }&#10;}));&#10;&#10;const TrendBox = styled(Box)&lt;{ direction: 'up' | 'down' }&gt;(({ theme, direction }) =&gt; ({&#10;  display: 'flex',&#10;  alignItems: 'center',&#10;  gap: theme.spacing(0.5),&#10;  color: direction === 'up' ? theme.palette.success.main : theme.palette.error.main&#10;}));&#10;&#10;const KPIWidget: React.FC&lt;KPIWidgetProps&gt; = ({ title, value, trend, icon }) =&gt; {&#10;  return (&#10;    &lt;WidgetPaper elevation={2}&gt;&#10;      &lt;Box sx={{ display: 'flex', justifyContent: 'space-between', alignItems: 'flex-start', mb: 2 }}&gt;&#10;        &lt;Typography variant=&quot;subtitle2&quot; color=&quot;textSecondary&quot;&gt;&#10;          {title}&#10;        &lt;/Typography&gt;&#10;        {icon &amp;&amp; (&#10;          &lt;Box sx={{ color: 'primary.main' }}&gt;&#10;            {icon}&#10;          &lt;/Box&gt;&#10;        )}&#10;      &lt;/Box&gt;&#10;      &#10;      &lt;Typography variant=&quot;h4&quot; component=&quot;div&quot; sx={{ mb: 1, fontWeight: 'medium' }}&gt;&#10;        {value}&#10;      &lt;/Typography&gt;&#10;&#10;      {trend &amp;&amp; (&#10;        &lt;TrendBox direction={trend.direction}&gt;&#10;          {trend.direction === 'up' ? &lt;TrendingUpIcon /&gt; : &lt;TrendingDownIcon /&gt;}&#10;          &lt;Typography variant=&quot;body2&quot;&gt;&#10;            {trend.value.toFixed(1)}% {trend.direction === 'up' ? 'augmentation' : 'diminution'}&#10;          &lt;/Typography&gt;&#10;        &lt;/TrendBox&gt;&#10;      )}&#10;    &lt;/WidgetPaper&gt;&#10;  );&#10;};&#10;&#10;export default KPIWidget;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/components/PrivateRoute.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/components/PrivateRoute.tsx" />
              <option name="originalContent" value="import React from 'react';&#10;import { Navigate } from 'react-router-dom';&#10;import { useAuth } from '../hooks/useAuth';&#10;&#10;interface PrivateRouteProps {&#10;  children: React.ReactNode;&#10;}&#10;&#10;const PrivateRoute: React.FC&lt;PrivateRouteProps&gt; = ({ children }) =&gt; {&#10;  const { isAuthenticated } = useAuth();&#10;&#10;};&#10;&#10;export default PrivateRoute;&#10;" />
              <option name="updatedContent" value="import React from 'react';&#10;import { Navigate } from 'react-router-dom';&#10;import { useAuth } from '../hooks/useAuth';&#10;&#10;interface PrivateRouteProps {&#10;  children: React.ReactNode;&#10;}&#10;&#10;const PrivateRoute: React.FC&lt;PrivateRouteProps&gt; = ({ children }) =&gt; {&#10;  const { isAuthenticated, isLoading } = useAuth();&#10;&#10;  if (isLoading) return null; // wait for auth status to resolve to avoid redirect loop&#10;  return isAuthenticated ? &lt;&gt;{children}&lt;/&gt; : &lt;Navigate to=&quot;/login&quot; replace /&gt;;&#10;};&#10;&#10;export default PrivateRoute;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/hooks/useAuth.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/hooks/useAuth.ts" />
              <option name="originalContent" value="import { useState, useEffect } from 'react';&#10;import { useSelector } from 'react-redux';&#10;import { RootState } from '../store/store';&#10;&#10;export const useAuth = () =&gt; {&#10;  const { user, isAuthenticated, loading } = useSelector((state: RootState) =&gt; state.auth);&#10;&#10;  const [isLoading, setIsLoading] = useState(true);&#10;&#10;  useEffect(() =&gt; {&#10;    if (!loading) {&#10;      setIsLoading(false);&#10;    }&#10;  }, [loading]);&#10;&#10;  return {&#10;    user,&#10;    isAuthenticated,&#10;    isLoading&#10;  };&#10;};&#10;&#10;export default useAuth;&#10;" />
              <option name="updatedContent" value="import { useState, useEffect, useCallback, useMemo } from 'react';&#10;import { useSelector, useDispatch } from 'react-redux';&#10;import { RootState } from '../store/store';&#10;import { setUser as setUserAction } from '../store/slices/authSlice';&#10;import { AppDispatch } from '../store/store';&#10;&#10;export const useAuth = () =&gt; {&#10;  const { user, isAuthenticated, loading } = useSelector((state: RootState) =&gt; state.auth);&#10;  const dispatch = useDispatch&lt;AppDispatch&gt;();&#10;&#10;  const [isLoading, setIsLoading] = useState(true);&#10;&#10;  useEffect(() =&gt; {&#10;    if (!loading) {&#10;      setIsLoading(false);&#10;    }&#10;  }, [loading]);&#10;&#10;  // Memoize setUser so its identity is stable between renders.&#10;  const setUser = useCallback((u: typeof user) =&gt; {&#10;    dispatch(setUserAction(u as any));&#10;  }, [dispatch]);&#10;&#10;  // Return a memoized object to avoid causing re-renders in consumers when not necessary.&#10;  return useMemo(() =&gt; ({&#10;    user,&#10;    isAuthenticated,&#10;    isLoading,&#10;    setUser,&#10;  }), [user, isAuthenticated, isLoading, setUser]);&#10;};&#10;&#10;export default useAuth;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/index.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/index.tsx" />
              <option name="updatedContent" value="import React from 'react';&#10;import ReactDOM from 'react-dom/client';&#10;import { BrowserRouter } from 'react-router-dom';&#10;import App from './App';&#10;import './index.css';&#10;import reportWebVitals from './reportWebVitals';&#10;&#10;const rootElement = document.getElementById('root') as HTMLElement;&#10;const root = ReactDOM.createRoot(rootElement);&#10;&#10;root.render(&#10;  &lt;React.StrictMode&gt;&#10;    &lt;BrowserRouter&gt;&#10;      &lt;App /&gt;&#10;    &lt;/BrowserRouter&gt;&#10;  &lt;/React.StrictMode&gt;&#10;);&#10;&#10;reportWebVitals();" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/layouts/EnterpriseLayout.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/layouts/EnterpriseLayout.tsx" />
              <option name="updatedContent" value="import React from 'react';&#10;import { Box, Drawer, List, ListItem, ListItemIcon, ListItemText, AppBar, Toolbar, Typography, IconButton } from '@mui/material';&#10;import {&#10;  Dashboard as DashboardIcon,&#10;  Description as DocumentIcon,&#10;  Assessment as KPIIcon,&#10;  CalendarToday as VisitIcon,&#10;  Person as ProfileIcon,&#10;  Message as MessageIcon,&#10;  Menu as MenuIcon&#10;} from '@mui/icons-material';&#10;import { useNavigate } from 'react-router-dom';&#10;&#10;const drawerWidth = 240;&#10;&#10;const EnterpriseLayout = ({ children }: { children: React.ReactNode }) =&gt; {&#10;  const navigate = useNavigate();&#10;  const [mobileOpen, setMobileOpen] = React.useState(false);&#10;&#10;  const menuItems = [&#10;    { text: 'Dashboard', icon: &lt;DashboardIcon /&gt;, path: '/enterprise/dashboard' },&#10;    { text: 'Documents', icon: &lt;DocumentIcon /&gt;, path: '/enterprise/documents' },&#10;    { text: 'KPI History', icon: &lt;KPIIcon /&gt;, path: '/enterprise/kpis' },&#10;    { text: 'Visits', icon: &lt;VisitIcon /&gt;, path: '/enterprise/visits' },&#10;    { text: 'Messages', icon: &lt;MessageIcon /&gt;, path: '/enterprise/messages' },&#10;    { text: 'Profile', icon: &lt;ProfileIcon /&gt;, path: '/enterprise/profile' },&#10;  ];&#10;&#10;  const drawer = (&#10;    &lt;div&gt;&#10;      &lt;Toolbar /&gt;&#10;      &lt;List&gt;&#10;        {menuItems.map((item) =&gt; (&#10;          &lt;ListItem button key={item.text} onClick={() =&gt; navigate(item.path)}&gt;&#10;            &lt;ListItemIcon&gt;{item.icon}&lt;/ListItemIcon&gt;&#10;            &lt;ListItemText primary={item.text} /&gt;&#10;          &lt;/ListItem&gt;&#10;        ))}&#10;      &lt;/List&gt;&#10;    &lt;/div&gt;&#10;  );&#10;&#10;  return (&#10;    &lt;Box sx={{ display: 'flex' }}&gt;&#10;      &lt;AppBar&#10;        position=&quot;fixed&quot;&#10;        sx={{&#10;          width: { sm: `calc(100% - ${drawerWidth}px)` },&#10;          ml: { sm: `${drawerWidth}px` }&#10;        }}&#10;      &gt;&#10;        &lt;Toolbar&gt;&#10;          &lt;IconButton&#10;            color=&quot;inherit&quot;&#10;            edge=&quot;start&quot;&#10;            onClick={() =&gt; setMobileOpen(!mobileOpen)}&#10;            sx={{ mr: 2, display: { sm: 'none' } }}&#10;          &gt;&#10;            &lt;MenuIcon /&gt;&#10;          &lt;/IconButton&gt;&#10;          &lt;Typography variant=&quot;h6&quot; noWrap component=&quot;div&quot;&gt;&#10;            Enterprise Portal&#10;          &lt;/Typography&gt;&#10;        &lt;/Toolbar&gt;&#10;      &lt;/AppBar&gt;&#10;&#10;      &lt;Box&#10;        component=&quot;nav&quot;&#10;        sx={{ width: { sm: drawerWidth }, flexShrink: { sm: 0 } }}&#10;      &gt;&#10;        &lt;Drawer&#10;          variant=&quot;temporary&quot;&#10;          open={mobileOpen}&#10;          onClose={() =&gt; setMobileOpen(false)}&#10;          ModalProps={{ keepMounted: true }}&#10;          sx={{&#10;            display: { xs: 'block', sm: 'none' },&#10;            '&amp; .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },&#10;          }}&#10;        &gt;&#10;          {drawer}&#10;        &lt;/Drawer&gt;&#10;        &lt;Drawer&#10;          variant=&quot;permanent&quot;&#10;          sx={{&#10;            display: { xs: 'none', sm: 'block' },&#10;            '&amp; .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },&#10;          }}&#10;          open&#10;        &gt;&#10;          {drawer}&#10;        &lt;/Drawer&gt;&#10;      &lt;/Box&gt;&#10;&#10;      &lt;Box&#10;        component=&quot;main&quot;&#10;        sx={{&#10;          flexGrow: 1,&#10;          p: 3,&#10;          width: { sm: `calc(100% - ${drawerWidth}px)` },&#10;          marginLeft: { sm: `${drawerWidth}px` }&#10;        }}&#10;      &gt;&#10;        &lt;Toolbar /&gt;&#10;        {children}&#10;      &lt;/Box&gt;&#10;    &lt;/Box&gt;&#10;  );&#10;};&#10;&#10;export default EnterpriseLayout;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/pages/ControlsPage.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/pages/ControlsPage.tsx" />
              <option name="updatedContent" value="import React from 'react';&#10;import { Box, Paper, Typography } from '@mui/material';&#10;&#10;const ControlsPage: React.FC = () =&gt; {&#10;  return (&#10;    &lt;Box sx={{ p: 3 }}&gt;&#10;      &lt;Paper sx={{ p: 3 }}&gt;&#10;        &lt;Typography variant=&quot;h5&quot; gutterBottom&gt;Controls / Visits&lt;/Typography&gt;&#10;        &lt;Typography variant=&quot;body2&quot; color=&quot;textSecondary&quot;&gt;&#10;          List of scheduled and past controls (placeholder). Inspector assignments and visit reports will appear here.&#10;        &lt;/Typography&gt;&#10;      &lt;/Paper&gt;&#10;    &lt;/Box&gt;&#10;  );&#10;};&#10;&#10;export default ControlsPage;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/pages/DocumentsPage.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/pages/DocumentsPage.tsx" />
              <option name="originalContent" value="import React from 'react';&#10;import { Box, Paper, Typography } from '@mui/material';&#10;import DocumentUploader from '../components/EntrepriseDashboard/DocumentUploader';&#10;&#10;const DocumentsPage: React.FC = () =&gt; {&#10;  return (&#10;    &lt;Box sx={{ p: 3 }}&gt;&#10;      &lt;Paper sx={{ p: 3 }}&gt;&#10;        &lt;Typography variant=&quot;h5&quot; gutterBottom&gt;Documents requis&lt;/Typography&gt;&#10;        &lt;Typography variant=&quot;body2&quot; color=&quot;textSecondary&quot; sx={{ mb: 2 }}&gt;&#10;          Liste des documents exigés, statuts et dates d'échéance. Téléversez les fichiers demandés.&#10;        &lt;/Typography&gt;&#10;        &lt;DocumentUploader /&gt;&#10;      &lt;/Paper&gt;&#10;    &lt;/Box&gt;&#10;  );&#10;};&#10;&#10;export default DocumentsPage;&#10;&#10;" />
              <option name="updatedContent" value="import React from 'react';&#10;import { Box, Typography } from '@mui/material';&#10;import DocumentsGallery from '../components/Documents/DocumentsGallery';&#10;&#10;const DocumentsPage: React.FC = () =&gt; {&#10;  return (&#10;    &lt;Box sx={{ p: 3 }}&gt;&#10;      &lt;Typography variant=&quot;h4&quot; gutterBottom&gt;&#10;        Gestion des Documents&#10;      &lt;/Typography&gt;&#10;      &lt;Typography variant=&quot;subtitle1&quot; color=&quot;textSecondary&quot; paragraph&gt;&#10;        Gérez vos documents requis et suivez leur statut de validation&#10;      &lt;/Typography&gt;&#10;      &#10;      &lt;DocumentsGallery /&gt;&#10;    &lt;/Box&gt;&#10;  );&#10;};&#10;&#10;export default DocumentsPage;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/pages/Enterprise/VisitsPage.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/pages/Enterprise/VisitsPage.tsx" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/pages/EntrepriseAffiliations.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/pages/EntrepriseAffiliations.tsx" />
              <option name="updatedContent" value="import React from 'react';&#10;import { Box, Paper, Typography, List, ListItem, ListItemText, Divider } from '@mui/material';&#10;&#10;const EntrepriseAffiliations: React.FC = () =&gt; {&#10;  // TODO: fetch public list from entrepriseService.getAffiliations()&#10;  const mock = [&#10;    { id: '1', name: 'Entreprise A', secteur: 'Tertiaire', ville: 'Douala' },&#10;    { id: '2', name: 'Entreprise B', secteur: 'Secondaire', ville: 'Yaoundé' }&#10;  ];&#10;&#10;  return (&#10;    &lt;Box sx={{ p: 3 }}&gt;&#10;      &lt;Paper sx={{ p: 3 }}&gt;&#10;        &lt;Typography variant=&quot;h5&quot; gutterBottom&gt;Entreprises affiliées (informations publiques)&lt;/Typography&gt;&#10;        &lt;List&gt;&#10;          {mock.map(e =&gt; (&#10;            &lt;React.Fragment key={e.id}&gt;&#10;              &lt;ListItem button component=&quot;a&quot; href={`#/entreprises/${e.id}`}&gt;&#10;                &lt;ListItemText primary={e.name} secondary={`${e.secteur} — ${e.ville}`} /&gt;&#10;              &lt;/ListItem&gt;&#10;              &lt;Divider /&gt;&#10;            &lt;/React.Fragment&gt;&#10;          ))}&#10;        &lt;/List&gt;&#10;      &lt;/Paper&gt;&#10;    &lt;/Box&gt;&#10;  );&#10;};&#10;&#10;export default EntrepriseAffiliations;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/pages/EntrepriseOverview.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/pages/EntrepriseOverview.tsx" />
              <option name="originalContent" value="&#10;&#10;" />
              <option name="updatedContent" value="import React, { useEffect, useState } from 'react';&#10;import { Box, Paper, Typography, Grid, CircularProgress, Button, Stack } from '@mui/material';&#10;import KPIWidget from '../components/EntrepriseDashboard/KPIWidget';&#10;import ComplianceTrafficLight from '../components/EntrepriseDashboard/ComplianceTrafficLight';&#10;import ChartWrapper from '../components/EntrepriseDashboard/ChartWrapper';&#10;import VisitsCalendar from '../components/EntrepriseDashboard/VisitsCalendar';&#10;import entrepriseService, { EnterpriseOverview } from '../services/entrepriseService';&#10;import { useAuth } from '../hooks/useAuth';&#10;import UploadFileIcon from '@mui/icons-material/UploadFile';&#10;import AssessmentIcon from '@mui/icons-material/Assessment';&#10;import CalendarMonthIcon from '@mui/icons-material/CalendarMonth';&#10;&#10;const EntrepriseOverview: React.FC = () =&gt; {&#10;  const [loading, setLoading] = useState(true);&#10;  const [overview, setOverview] = useState&lt;EnterpriseOverview | null&gt;(null);&#10;  const { user } = useAuth();&#10;&#10;  useEffect(() =&gt; {&#10;    const fetchOverview = async () =&gt; {&#10;      try {&#10;        if (user?.entrepriseId) {&#10;          const data = await entrepriseService.getEnterpriseOverview(user.entrepriseId);&#10;          setOverview(data);&#10;        }&#10;      } catch (error) {&#10;        console.error('Error fetching overview:', error);&#10;      } finally {&#10;        setLoading(false);&#10;      }&#10;    };&#10;&#10;    fetchOverview();&#10;  }, [user]);&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;Box sx={{ display: 'flex', justifyContent: 'center', alignItems: 'center', height: '50vh' }}&gt;&#10;        &lt;CircularProgress /&gt;&#10;      &lt;/Box&gt;&#10;    );&#10;  }&#10;&#10;  return (&#10;    &lt;Box sx={{ p: 3 }}&gt;&#10;      &lt;Grid container spacing={3}&gt;&#10;        {/* Compliance Status */}&#10;        &lt;Grid item xs={12}&gt;&#10;          &lt;Paper sx={{ p: 3, mb: 3 }}&gt;&#10;            &lt;Box sx={{ display: 'flex', alignItems: 'center', justifyContent: 'space-between' }}&gt;&#10;              &lt;Typography variant=&quot;h5&quot;&gt;État de conformité&lt;/Typography&gt;&#10;              &lt;ComplianceTrafficLight status={overview?.complianceStatus || 'yellow'} /&gt;&#10;            &lt;/Box&gt;&#10;          &lt;/Paper&gt;&#10;        &lt;/Grid&gt;&#10;&#10;        {/* Quick Actions */}&#10;        &lt;Grid item xs={12}&gt;&#10;          &lt;Stack direction=&quot;row&quot; spacing={2} sx={{ mb: 3 }}&gt;&#10;            &lt;Button&#10;              variant=&quot;contained&quot;&#10;              startIcon={&lt;UploadFileIcon /&gt;}&#10;              onClick={() =&gt; window.location.href = '/documents'}&#10;            &gt;&#10;              Télécharger un document&#10;            &lt;/Button&gt;&#10;            &lt;Button&#10;              variant=&quot;contained&quot;&#10;              startIcon={&lt;AssessmentIcon /&gt;}&#10;              onClick={() =&gt; window.location.href = '/kpi-history'}&#10;            &gt;&#10;              Déclarer un indicateur&#10;            &lt;/Button&gt;&#10;            &lt;Button&#10;              variant=&quot;contained&quot;&#10;              startIcon={&lt;CalendarMonthIcon /&gt;}&#10;              onClick={() =&gt; window.location.href = '/controls'}&#10;            &gt;&#10;              Planifier une visite&#10;            &lt;/Button&gt;&#10;          &lt;/Stack&gt;&#10;        &lt;/Grid&gt;&#10;&#10;        {/* KPI Widgets */}&#10;        &lt;Grid item xs={12} md={4}&gt;&#10;          &lt;KPIWidget &#10;            title=&quot;Investissement actuel&quot; &#10;            value={overview?.currentInvestment?.toLocaleString('fr-FR', { style: 'currency', currency: 'XAF' }) || '--'} &#10;            trend={overview?.investmentTrend}&#10;          /&gt;&#10;        &lt;/Grid&gt;&#10;        &lt;Grid item xs={12} md={4}&gt;&#10;          &lt;KPIWidget &#10;            title=&quot;Employés&quot; &#10;            value={overview?.employeeCount?.toString() || '--'}&#10;            trend={overview?.employeeTrend}&#10;          /&gt;&#10;        &lt;/Grid&gt;&#10;        &lt;Grid item xs={12} md={4}&gt;&#10;          &lt;KPIWidget &#10;            title=&quot;Exportations&quot; &#10;            value={overview?.exportsValue?.toLocaleString('fr-FR', { style: 'currency', currency: 'XAF' }) || '--'}&#10;            trend={overview?.exportsTrend}&#10;          /&gt;&#10;        &lt;/Grid&gt;&#10;&#10;        {/* Charts */}&#10;        &lt;Grid item xs={12} md={8}&gt;&#10;          &lt;ChartWrapper title=&quot;Tendances des 12 derniers mois&quot;&gt;&#10;            {/* Chart content will be implemented in ChartWrapper component */}&#10;          &lt;/ChartWrapper&gt;&#10;        &lt;/Grid&gt;&#10;&#10;        {/* Calendar Preview */}&#10;        &lt;Grid item xs={12} md={4}&gt;&#10;          &lt;Paper sx={{ p: 2 }}&gt;&#10;            &lt;Typography variant=&quot;h6&quot; gutterBottom&gt;Prochaines visites&lt;/Typography&gt;&#10;            &lt;VisitsCalendar compact /&gt;&#10;          &lt;/Paper&gt;&#10;        &lt;/Grid&gt;&#10;      &lt;/Grid&gt;&#10;    &lt;/Box&gt;&#10;  );&#10;}&#10;&#10;export default EntrepriseOverview;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/pages/KPIHistoryPage.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/pages/KPIHistoryPage.tsx" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="import React, { useState, useEffect } from 'react';&#10;import {&#10;  Box,&#10;  Paper,&#10;  Typography,&#10;  Grid,&#10;  Table,&#10;  TableBody,&#10;  TableCell,&#10;  TableContainer,&#10;  TableHead,&#10;  TableRow,&#10;  Chip,&#10;  CircularProgress,&#10;  Select,&#10;  MenuItem,&#10;  FormControl,&#10;  InputLabel&#10;} from '@mui/material';&#10;import {&#10;  LineChart,&#10;  Line,&#10;  XAxis,&#10;  YAxis,&#10;  CartesianGrid,&#10;  Tooltip,&#10;  Legend,&#10;  ResponsiveContainer&#10;} from 'recharts';&#10;import { useAuth } from '../hooks/useAuth';&#10;import kpiService, { KPIHistory } from '../services/kpiService';&#10;&#10;const KPIHistoryPage: React.FC = () =&gt; {&#10;  const [loading, setLoading] = useState(true);&#10;  const [kpiHistory, setKpiHistory] = useState&lt;KPIHistory[]&gt;([]);&#10;  const [selectedKPI, setSelectedKPI] = useState&lt;string&gt;('');&#10;  const { user } = useAuth();&#10;&#10;  useEffect(() =&gt; {&#10;    const fetchKPIHistory = async () =&gt; {&#10;      if (user?.entrepriseId) {&#10;        try {&#10;          const data = await kpiService.getKPIHistory(user.entrepriseId);&#10;          setKpiHistory(data);&#10;          if (data.length &gt; 0) {&#10;            setSelectedKPI(data[0].indicatorId);&#10;          }&#10;        } catch (error) {&#10;          console.error('Error fetching KPI history:', error);&#10;        } finally {&#10;          setLoading(false);&#10;        }&#10;      }&#10;    };&#10;&#10;    fetchKPIHistory();&#10;  }, [user]);&#10;&#10;  if (loading) {&#10;    return (&#10;      &lt;Box sx={{ display: 'flex', justifyContent: 'center', p: 3 }}&gt;&#10;        &lt;CircularProgress /&gt;&#10;      &lt;/Box&gt;&#10;    );&#10;  }&#10;&#10;  const selectedKPIData = kpiHistory.find(k =&gt; k.indicatorId === selectedKPI);&#10;&#10;  return (&#10;    &lt;Box sx={{ p: 3 }}&gt;&#10;      &lt;Typography variant=&quot;h4&quot; gutterBottom&gt;&#10;        Historique des Indicateurs&#10;      &lt;/Typography&gt;&#10;&#10;      &lt;Grid container spacing={3}&gt;&#10;        &lt;Grid item xs={12}&gt;&#10;          &lt;Paper sx={{ p: 3 }}&gt;&#10;            &lt;FormControl fullWidth sx={{ mb: 3 }}&gt;&#10;              &lt;InputLabel&gt;Sélectionner un indicateur&lt;/InputLabel&gt;&#10;              &lt;Select&#10;                value={selectedKPI}&#10;                onChange={(e) =&gt; setSelectedKPI(e.target.value)}&#10;                label=&quot;Sélectionner un indicateur&quot;&#10;              &gt;&#10;                {kpiHistory.map((kpi) =&gt; (&#10;                  &lt;MenuItem key={kpi.indicatorId} value={kpi.indicatorId}&gt;&#10;                    {kpi.name}&#10;                  &lt;/MenuItem&gt;&#10;                ))}&#10;              &lt;/Select&gt;&#10;            &lt;/FormControl&gt;&#10;&#10;            {selectedKPIData &amp;&amp; (&#10;              &lt;&gt;&#10;                &lt;Typography variant=&quot;h6&quot; gutterBottom&gt;&#10;                  {selectedKPIData.name}&#10;                &lt;/Typography&gt;&#10;                &#10;                &lt;Box sx={{ height: 400, mb: 4 }}&gt;&#10;                  &lt;ResponsiveContainer&gt;&#10;                    &lt;LineChart data={selectedKPIData.history}&gt;&#10;                      &lt;CartesianGrid strokeDasharray=&quot;3 3&quot; /&gt;&#10;                      &lt;XAxis dataKey=&quot;date&quot; /&gt;&#10;                      &lt;YAxis /&gt;&#10;                      &lt;Tooltip /&gt;&#10;                      &lt;Legend /&gt;&#10;                      &lt;Line&#10;                        type=&quot;monotone&quot;&#10;                        dataKey=&quot;value&quot;&#10;                        stroke=&quot;#8884d8&quot;&#10;                        activeDot={{ r: 8 }}&#10;                      /&gt;&#10;                    &lt;/LineChart&gt;&#10;                  &lt;/ResponsiveContainer&gt;&#10;                &lt;/Box&gt;&#10;&#10;                &lt;TableContainer&gt;&#10;                  &lt;Table&gt;&#10;                    &lt;TableHead&gt;&#10;                      &lt;TableRow&gt;&#10;                        &lt;TableCell&gt;Date&lt;/TableCell&gt;&#10;                        &lt;TableCell&gt;Valeur&lt;/TableCell&gt;&#10;                        &lt;TableCell&gt;Statut&lt;/TableCell&gt;&#10;                        &lt;TableCell&gt;Soumis par&lt;/TableCell&gt;&#10;                      &lt;/TableRow&gt;&#10;                    &lt;/TableHead&gt;&#10;                    &lt;TableBody&gt;&#10;                      {selectedKPIData.history.map((entry, index) =&gt; (&#10;                        &lt;TableRow key={index}&gt;&#10;                          &lt;TableCell&gt;{new Date(entry.date).toLocaleDateString()}&lt;/TableCell&gt;&#10;                          &lt;TableCell&gt;{entry.value}&lt;/TableCell&gt;&#10;                          &lt;TableCell&gt;&#10;                            &lt;Chip&#10;                              label={entry.status}&#10;                              color={entry.status === 'VALIDATED' ? 'success' : 'warning'}&#10;                              size=&quot;small&quot;&#10;                            /&gt;&#10;                          &lt;/TableCell&gt;&#10;                          &lt;TableCell&gt;{entry.submittedBy}&lt;/TableCell&gt;&#10;                        &lt;/TableRow&gt;&#10;                      ))}&#10;                    &lt;/TableBody&gt;&#10;                  &lt;/Table&gt;&#10;                &lt;/TableContainer&gt;&#10;              &lt;/&gt;&#10;            )}&#10;          &lt;/Paper&gt;&#10;        &lt;/Grid&gt;&#10;      &lt;/Grid&gt;&#10;    &lt;/Box&gt;&#10;  );&#10;};&#10;&#10;export default KPIHistoryPage;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/pages/MessagesPage.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/pages/MessagesPage.tsx" />
              <option name="updatedContent" value="import React from 'react';&#10;import { Box, Paper, Typography } from '@mui/material';&#10;&#10;const MessagesPage: React.FC = () =&gt; {&#10;  return (&#10;    &lt;Box sx={{ p: 3 }}&gt;&#10;      &lt;Paper sx={{ p: 3 }}&gt;&#10;        &lt;Typography variant=&quot;h5&quot; gutterBottom&gt;Messages&lt;/Typography&gt;&#10;        &lt;Typography variant=&quot;body2&quot; color=&quot;textSecondary&quot;&gt;Secure messaging with API contacts (placeholder).&lt;/Typography&gt;&#10;      &lt;/Paper&gt;&#10;    &lt;/Box&gt;&#10;  );&#10;};&#10;&#10;export default MessagesPage;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/pages/ProfilePage.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/pages/ProfilePage.tsx" />
              <option name="updatedContent" value="import React from 'react';&#10;import { Box, Paper, Typography } from '@mui/material';&#10;&#10;const ProfilePage: React.FC = () =&gt; {&#10;  return (&#10;    &lt;Box sx={{ p: 3 }}&gt;&#10;      &lt;Paper sx={{ p: 3 }}&gt;&#10;        &lt;Typography variant=&quot;h5&quot; gutterBottom&gt;Profile&lt;/Typography&gt;&#10;        &lt;Typography variant=&quot;body2&quot; color=&quot;textSecondary&quot;&gt;Edit your user profile and contact details (placeholder).&lt;/Typography&gt;&#10;      &lt;/Paper&gt;&#10;    &lt;/Box&gt;&#10;  );&#10;};&#10;&#10;export default ProfilePage;&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/pages/auth/Login.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/pages/auth/Login.tsx" />
              <option name="originalContent" value="import React, { useState } from 'react';&#10;import { useNavigate } from 'react-router-dom';&#10;import {&#10;  Box,&#10;  Button,&#10;  TextField,&#10;  Typography,&#10;  Container,&#10;  Paper,&#10;  Alert&#10;} from '@mui/material';&#10;import { login } from '../../services/authService';&#10;import { useAuth } from '../../hooks/useAuth';&#10;&#10;const Login = () =&gt; {&#10;  const navigate = useNavigate();&#10;  const { setUser } = useAuth();&#10;  const [error, setError] = useState('');&#10;  const [loading, setLoading] = useState(false);&#10;&#10;  const handleSubmit = async (event: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; {&#10;    event.preventDefault();&#10;    setError('');&#10;    setLoading(true);&#10;&#10;    const formData = new FormData(event.currentTarget);&#10;    const email = formData.get('email') as string;&#10;    const password = formData.get('password') as string;&#10;&#10;" />
              <option name="updatedContent" value="import React, { useState } from 'react';&#10;import { useNavigate } from 'react-router-dom';&#10;import {&#10;  Box,&#10;  Button,&#10;  TextField,&#10;  Typography,&#10;  Container,&#10;  Paper,&#10;  Alert&#10;} from '@mui/material';&#10;import { login, setAuthToken } from '../../services/authService';&#10;import { useAuth } from '../../hooks/useAuth';&#10;&#10;const Login = () =&gt; {&#10;  const navigate = useNavigate();&#10;  const { setUser } = useAuth();&#10;  const [error, setError] = useState('');&#10;  const [loading, setLoading] = useState(false);&#10;&#10;  const handleSubmit = async (event: React.FormEvent&lt;HTMLFormElement&gt;) =&gt; {&#10;    event.preventDefault();&#10;    setError('');&#10;    setLoading(true);&#10;&#10;    const formData = new FormData(event.currentTarget);&#10;    const email = formData.get('email') as string;&#10;    const password = formData.get('password') as string;&#10;&#10;    try {&#10;      const res = await login({ email, password });&#10;      const user = res.user;&#10;      const token = res.token;&#10;      const defaultRoute = res.defaultRoute || '/';&#10;      if (token) setAuthToken(token);&#10;      setUser(user);&#10;      navigate(defaultRoute);&#10;    } catch (err: any) {&#10;      setError(err.response?.data?.message || 'An error occurred during login');&#10;    } finally {&#10;      setLoading(false);&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;Container component=&quot;main&quot; maxWidth=&quot;xs&quot;&gt;&#10;      &lt;Box&#10;        sx={{&#10;          marginTop: 8,&#10;          display: 'flex',&#10;          flexDirection: 'column',&#10;          alignItems: 'center',&#10;        }}&#10;      &gt;&#10;        &lt;Paper elevation={3} sx={{ p: 4, width: '100%' }}&gt;&#10;          &lt;Typography component=&quot;h1&quot; variant=&quot;h5&quot; align=&quot;center&quot; gutterBottom&gt;&#10;            Sign In&#10;          &lt;/Typography&gt;&#10;&#10;          {error &amp;&amp; (&#10;            &lt;Alert severity=&quot;error&quot; sx={{ mb: 2 }}&gt;&#10;              {error}&#10;            &lt;/Alert&gt;&#10;          )}&#10;&#10;          &lt;Box component=&quot;form&quot; onSubmit={handleSubmit} noValidate&gt;&#10;            &lt;TextField&#10;              margin=&quot;normal&quot;&#10;              required&#10;              fullWidth&#10;              id=&quot;email&quot;&#10;              label=&quot;Email Address&quot;&#10;              name=&quot;email&quot;&#10;              autoComplete=&quot;email&quot;&#10;              autoFocus&#10;            /&gt;&#10;            &lt;TextField&#10;              margin=&quot;normal&quot;&#10;              required&#10;              fullWidth&#10;              name=&quot;password&quot;&#10;              label=&quot;Password&quot;&#10;              type=&quot;password&quot;&#10;              id=&quot;password&quot;&#10;              autoComplete=&quot;current-password&quot;&#10;            /&gt;&#10;            &lt;Button&#10;              type=&quot;submit&quot;&#10;              fullWidth&#10;              variant=&quot;contained&quot;&#10;              sx={{ mt: 3, mb: 2 }}&#10;              disabled={loading}&#10;            &gt;&#10;              {loading ? 'Signing in...' : 'Sign In'}&#10;            &lt;/Button&gt;&#10;          &lt;/Box&gt;&#10;        &lt;/Paper&gt;&#10;      &lt;/Box&gt;&#10;    &lt;/Container&gt;&#10;  );&#10;};&#10;&#10;export default Login;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/pages/auth/Register.tsx">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/pages/auth/Register.tsx" />
              <option name="originalContent" value="import React from 'react';&#10;import { useNavigate } from 'react-router-dom';&#10;import {&#10;  Container,&#10;  Typography,&#10;  TextField,&#10;  Button,&#10;  Box,&#10;  Link,&#10;  Paper,&#10;  FormControl,&#10;  InputLabel,&#10;  Select,&#10;  MenuItem,&#10;  FormHelperText&#10;  FormHelperText&#10;" />
              <option name="updatedContent" value="import React, { useState } from 'react';&#10;import { useNavigate } from 'react-router-dom';&#10;import {&#10;  Container,&#10;  Typography,&#10;  TextField,&#10;  Button,&#10;  Box,&#10;  Link,&#10;  Paper,&#10;  FormControl,&#10;  InputLabel,&#10;  Select,&#10;  MenuItem&#10;} from '@mui/material';&#10;import { register } from '../../services/authService';&#10;&#10;const Register: React.FC = () =&gt; {&#10;  const navigate = useNavigate();&#10;  const [formData, setFormData] = useState({&#10;    nom: '',&#10;    prenom: '',&#10;    email: '',&#10;    password: '',&#10;    role: 'entreprise'&#10;  });&#10;  const [error, setError] = useState('');&#10;&#10;  const handleChange = (e: React.ChangeEvent&lt;HTMLInputElement | { name?: string; value: unknown }&gt;) =&gt; {&#10;    const { name, value } = e.target;&#10;    setFormData(prev =&gt; ({&#10;      ...prev,&#10;      [name as string]: value&#10;    }));&#10;  };&#10;&#10;  const handleSubmit = async (e: React.FormEvent) =&gt; {&#10;    e.preventDefault();&#10;    try {&#10;      const response = await register(formData);&#10;      if (response.token) {&#10;        navigate('/dashboard');&#10;      }&#10;    } catch (err) {&#10;      setError('Une erreur est survenue lors de l\'inscription');&#10;    }&#10;  };&#10;&#10;  return (&#10;    &lt;Container component=&quot;main&quot; maxWidth=&quot;xs&quot;&gt;&#10;      &lt;Paper elevation={6} sx={{ p: 4, mt: 8 }}&gt;&#10;        &lt;Typography component=&quot;h1&quot; variant=&quot;h5&quot; align=&quot;center&quot; gutterBottom&gt;&#10;          Inscription&#10;        &lt;/Typography&gt;&#10;        &lt;Box component=&quot;form&quot; onSubmit={handleSubmit} sx={{ mt: 3 }}&gt;&#10;          &lt;TextField&#10;            margin=&quot;normal&quot;&#10;            required&#10;            fullWidth&#10;            name=&quot;nom&quot;&#10;            label=&quot;Nom&quot;&#10;            value={formData.nom}&#10;            onChange={handleChange}&#10;          /&gt;&#10;          &lt;TextField&#10;            margin=&quot;normal&quot;&#10;            required&#10;            fullWidth&#10;            name=&quot;prenom&quot;&#10;            label=&quot;Prénom&quot;&#10;            value={formData.prenom}&#10;            onChange={handleChange}&#10;          /&gt;&#10;          &lt;TextField&#10;            margin=&quot;normal&quot;&#10;            required&#10;            fullWidth&#10;            name=&quot;email&quot;&#10;            label=&quot;Email&quot;&#10;            type=&quot;email&quot;&#10;            value={formData.email}&#10;            onChange={handleChange}&#10;          /&gt;&#10;          &lt;TextField&#10;            margin=&quot;normal&quot;&#10;            required&#10;            fullWidth&#10;            name=&quot;password&quot;&#10;            label=&quot;Mot de passe&quot;&#10;            type=&quot;password&quot;&#10;            value={formData.password}&#10;            onChange={handleChange}&#10;          /&gt;&#10;          &lt;FormControl fullWidth margin=&quot;normal&quot;&gt;&#10;            &lt;InputLabel&gt;Type de compte&lt;/InputLabel&gt;&#10;            &lt;Select&#10;              name=&quot;role&quot;&#10;              value={formData.role}&#10;              label=&quot;Type de compte&quot;&#10;              onChange={handleChange}&#10;            &gt;&#10;              &lt;MenuItem value=&quot;entreprise&quot;&gt;Entreprise&lt;/MenuItem&gt;&#10;              &lt;MenuItem value=&quot;admin&quot;&gt;Admin&lt;/MenuItem&gt;&#10;            &lt;/Select&gt;&#10;          &lt;/FormControl&gt;&#10;&#10;          {error &amp;&amp; (&#10;            &lt;Typography color=&quot;error&quot; align=&quot;center&quot; sx={{ mt: 2 }}&gt;&#10;              {error}&#10;            &lt;/Typography&gt;&#10;          )}&#10;&#10;          &lt;Button&#10;            type=&quot;submit&quot;&#10;            fullWidth&#10;            variant=&quot;contained&quot;&#10;            sx={{ mt: 3, mb: 2 }}&#10;          &gt;&#10;            S'inscrire&#10;          &lt;/Button&gt;&#10;&#10;          &lt;Box textAlign=&quot;center&quot;&gt;&#10;            &lt;Link href=&quot;/login&quot; variant=&quot;body2&quot;&gt;&#10;              Déjà un compte? Connexion&#10;            &lt;/Link&gt;&#10;          &lt;/Box&gt;&#10;        &lt;/Box&gt;&#10;      &lt;/Paper&gt;&#10;    &lt;/Container&gt;&#10;  );&#10;};&#10;&#10;export default Register;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/services/authService.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/services/authService.ts" />
              <option name="updatedContent" value="import axios from 'axios';&#10;import { User } from '../types/auth.types';&#10;&#10;export interface LoginCredentials {&#10;  email: string;&#10;  password: string;&#10;}&#10;&#10;export interface RegisterData {&#10;  nom: string;&#10;  prenom: string;&#10;  email: string;&#10;  password: string;&#10;  role?: 'admin' | 'entreprise';&#10;  typeCompte?: 'admin' | 'entreprise';&#10;}&#10;&#10;export interface AuthResponse {&#10;  user: User;&#10;  token: string;&#10;}&#10;&#10;class AuthService {&#10;  private baseURL = '/api/auth';&#10;&#10;  async login(credentials: LoginCredentials): Promise&lt;AuthResponse&gt; {&#10;    const response = await axios.post(`${this.baseURL}/login`, credentials);&#10;    return response.data;&#10;  }&#10;&#10;  async register(data: RegisterData): Promise&lt;AuthResponse&gt; {&#10;    const payload = {&#10;      ...data,&#10;      typeCompte: data.role || 'entreprise'&#10;    };&#10;    const response = await axios.post(`${this.baseURL}/register`, payload);&#10;    return response.data;&#10;  }&#10;&#10;  async logout(): Promise&lt;void&gt; {&#10;    await axios.post(`${this.baseURL}/logout`);&#10;    localStorage.removeItem('token');&#10;  }&#10;&#10;  async getCurrentUser(): Promise&lt;User&gt; {&#10;    const response = await axios.get(`${this.baseURL}/me`);&#10;    return response.data;&#10;  }&#10;&#10;  setAuthToken(token: string): void {&#10;    localStorage.setItem('token', token);&#10;    axios.defaults.headers.common['Authorization'] = `Bearer ${token}`;&#10;  }&#10;&#10;  removeAuthToken(): void {&#10;    localStorage.removeItem('token');&#10;    delete axios.defaults.headers.common['Authorization'];&#10;  }&#10;&#10;  getStoredToken(): string | null {&#10;    return localStorage.getItem('token');&#10;  }&#10;}&#10;&#10;const authService = new AuthService();&#10;export const { login, register, logout, getCurrentUser, setAuthToken, removeAuthToken, getStoredToken } = authService;&#10;export default authService;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/services/documentService.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/services/documentService.ts" />
              <option name="updatedContent" value="import api from './api';&#10;&#10;export interface Document {&#10;  id: string;&#10;  type: string;&#10;  required: boolean;&#10;  dueDate: string;&#10;  status: 'RECEIVED' | 'WAITING' | 'EXPIRED' | 'UPDATE_REQUIRED';&#10;  files: Array&lt;{ name: string; url: string }&gt;;&#10;  uploadedAt?: string;&#10;  validatedBy?: string;&#10;}&#10;&#10;const documentService = {&#10;  getCompanyDocuments: async (companyId: string): Promise&lt;Document[]&gt; =&gt; {&#10;    const response = await api.get(`/documents/company/${companyId}`);&#10;    return response.data;&#10;  },&#10;&#10;  uploadDocument: async (companyId: string, documentType: string, file: File) =&gt; {&#10;    const formData = new FormData();&#10;    formData.append('file', file);&#10;    formData.append('type', documentType);&#10;    &#10;    const response = await api.post(`/documents/company/${companyId}/upload`, formData, {&#10;      headers: {&#10;        'Content-Type': 'multipart/form-data',&#10;      },&#10;    });&#10;    return response.data;&#10;  },&#10;&#10;  validateDocument: async (documentId: string, status: Document['status'], comment?: string) =&gt; {&#10;    const response = await api.put(`/documents/${documentId}/validate`, {&#10;      status,&#10;      comment,&#10;    });&#10;    return response.data;&#10;  },&#10;};&#10;&#10;export default documentService;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/services/kpiService.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/services/kpiService.ts" />
              <option name="originalContent" value="import api from './api';&#10;&#10;export interface KPI {&#10;  _id?: string;&#10;  nom: string;&#10;  valeur: number;&#10;  objectif: number;&#10;  unite: string;&#10;  entrepriseId: string;&#10;  periode: string;&#10;  createdAt?: Date;&#10;  updatedAt?: Date;&#10;" />
              <option name="updatedContent" value="import api from './api';&#10;&#10;export interface KPI {&#10;  _id: string;&#10;  name: string;&#10;  description: string;&#10;  targetValue: number;&#10;  unit: string;&#10;  frequency: 'daily' | 'weekly' | 'monthly' | 'quarterly' | 'yearly';&#10;  history: Array&lt;{&#10;    value: number;&#10;    date: string;&#10;    submittedBy: string;&#10;    status: 'pending' | 'validated' | 'rejected';&#10;    comment?: string;&#10;  }&gt;;&#10;}&#10;&#10;export interface KPISubmission {&#10;  kpiId: string;&#10;  value: number;&#10;  comment?: string;&#10;  enterpriseId: string;&#10;}&#10;&#10;const kpiService = {&#10;  getKPIsByEnterprise: async (enterpriseId: string): Promise&lt;KPI[]&gt; =&gt; {&#10;    const response = await api.get(`/kpis/enterprise/${enterpriseId}`);&#10;    return response.data;&#10;  },&#10;&#10;  getKPIHistory: async (kpiId: string, period?: string): Promise&lt;KPI['history']&gt; =&gt; {&#10;    const response = await api.get(`/kpis/${kpiId}/history`, {&#10;      params: { period }&#10;    });&#10;    return response.data;&#10;  },&#10;&#10;  submitKPIValue: async (submission: KPISubmission) =&gt; {&#10;    const response = await api.post(`/kpis/${submission.kpiId}/submit`, submission);&#10;    return response.data;&#10;  },&#10;&#10;  validateKPISubmission: async (kpiId: string, submissionId: string, status: 'validated' | 'rejected', comment?: string) =&gt; {&#10;    const response = await api.put(`/kpis/${kpiId}/submissions/${submissionId}`, {&#10;      status,&#10;      comment&#10;    });&#10;    return response.data;&#10;  },&#10;&#10;  getKPIOverview: async (enterpriseId: string) =&gt; {&#10;    const response = await api.get(`/kpis/enterprise/${enterpriseId}/overview`);&#10;    return response.data;&#10;  }&#10;};&#10;&#10;export default kpiService;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/services/reportService.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/services/reportService.ts" />
              <option name="updatedContent" value="import api from './api';&#10;&#10;interface ReportParams {&#10;  type: 'entreprises' | 'kpis' | 'performance';&#10;  format: 'pdf' | 'xlsx';&#10;  dateDebut?: string;&#10;  dateFin?: string;&#10;}&#10;&#10;interface ReportResponse {&#10;  success: boolean;&#10;  data: {&#10;    reportUrl: string;&#10;    filename: string;&#10;  };&#10;}&#10;&#10;interface ReportType {&#10;  id: string;&#10;  name: string;&#10;  description: string;&#10;  formats: string[];&#10;}&#10;&#10;const reportService = {&#10;  async generateReport(params: ReportParams): Promise&lt;ReportResponse&gt; {&#10;    const response = await api.post('/admin/reports/generate', params);&#10;    return response.data;&#10;  },&#10;&#10;  async getReportTypes(): Promise&lt;ReportType[]&gt; {&#10;    const response = await api.get('/admin/reports/types');&#10;    return response.data.data;&#10;  },&#10;&#10;  async downloadReport(url: string): Promise&lt;Blob&gt; {&#10;    const response = await api.get(url, { responseType: 'blob' });&#10;    return response.data;&#10;  }&#10;};&#10;&#10;export default reportService;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/services/socketService.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/services/socketService.ts" />
              <option name="updatedContent" value="import { io, Socket } from 'socket.io-client';&#10;import { getToken } from '../utils/authUtils';&#10;&#10;class SocketService {&#10;  private socket: Socket | null = null;&#10;  private listeners: Map&lt;string, Function[]&gt; = new Map();&#10;&#10;  connect() {&#10;    const token = getToken();&#10;    if (!token) return;&#10;&#10;    this.socket = io(process.env.REACT_APP_API_URL || 'http://localhost:5000', {&#10;      auth: { token }&#10;    });&#10;&#10;    this.socket.on('connect', () =&gt; {&#10;      console.log('Socket connected');&#10;    });&#10;&#10;    this.socket.on('connect_error', (error) =&gt; {&#10;      console.error('Socket connection error:', error);&#10;    });&#10;&#10;    // Set up indicator event listeners&#10;    this.socket.on('indicator:updated', (data) =&gt; {&#10;      this.notifyListeners('indicator:updated', data);&#10;    });&#10;&#10;    this.socket.on('indicator:validated', (data) =&gt; {&#10;      this.notifyListeners('indicator:validated', data);&#10;    });&#10;&#10;    this.socket.on('indicator:pending-validation', (data) =&gt; {&#10;      this.notifyListeners('indicator:pending-validation', data);&#10;    });&#10;  }&#10;&#10;  disconnect() {&#10;    if (this.socket) {&#10;      this.socket.disconnect();&#10;      this.socket = null;&#10;    }&#10;  }&#10;&#10;  addListener(event: string, callback: Function) {&#10;    if (!this.listeners.has(event)) {&#10;      this.listeners.set(event, []);&#10;    }&#10;    this.listeners.get(event)?.push(callback);&#10;  }&#10;&#10;  removeListener(event: string, callback: Function) {&#10;    const eventListeners = this.listeners.get(event);&#10;    if (eventListeners) {&#10;      const index = eventListeners.indexOf(callback);&#10;      if (index &gt; -1) {&#10;        eventListeners.splice(index, 1);&#10;      }&#10;    }&#10;  }&#10;&#10;  private notifyListeners(event: string, data: any) {&#10;    const eventListeners = this.listeners.get(event);&#10;    if (eventListeners) {&#10;      eventListeners.forEach(callback =&gt; callback(data));&#10;    }&#10;  }&#10;}&#10;&#10;export const socketService = new SocketService();&#10;export default socketService;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/services/visitService.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/services/visitService.ts" />
              <option name="updatedContent" value="import api from './api';&#10;&#10;export interface Visit {&#10;  _id: string;&#10;  enterpriseId: string;&#10;  inspectorId?: string;&#10;  scheduledAt: string;&#10;  status: 'SCHEDULED' | 'COMPLETED' | 'CANCELLED';&#10;  type: 'REGULAR' | 'FOLLOW_UP' | 'EMERGENCY';&#10;  report?: {&#10;    content: string;&#10;    files: Array&lt;{&#10;      name: string;&#10;      url: string;&#10;    }&gt;;&#10;    submittedAt: string;&#10;    submittedBy: string;&#10;    outcome: 'COMPLIANT' | 'NON_COMPLIANT' | 'NEEDS_FOLLOW_UP';&#10;  };&#10;}&#10;&#10;export interface VisitRequest {&#10;  enterpriseId: string;&#10;  scheduledAt: Date;&#10;  type: Visit['type'];&#10;  comment?: string;&#10;}&#10;&#10;const visitService = {&#10;  getVisitsByEnterprise: async (enterpriseId: string): Promise&lt;Visit[]&gt; =&gt; {&#10;    const response = await api.get(`/visits/enterprise/${enterpriseId}`);&#10;    return response.data;&#10;  },&#10;&#10;  requestVisit: async (request: VisitRequest): Promise&lt;Visit&gt; =&gt; {&#10;    const response = await api.post('/visits/request', request);&#10;    return response.data;&#10;  },&#10;&#10;  cancelVisit: async (visitId: string, reason: string): Promise&lt;Visit&gt; =&gt; {&#10;    const response = await api.put(`/visits/${visitId}/cancel`, { reason });&#10;    return response.data;&#10;  },&#10;&#10;  downloadVisitReport: async (visitId: string): Promise&lt;Blob&gt; =&gt; {&#10;    const response = await api.get(`/visits/${visitId}/report/download`, {&#10;      responseType: 'blob'&#10;    });&#10;    return response.data;&#10;  },&#10;&#10;  getUpcomingVisits: async (enterpriseId: string): Promise&lt;Visit[]&gt; =&gt; {&#10;    const response = await api.get(`/visits/enterprise/${enterpriseId}/upcoming`);&#10;    return response.data;&#10;  },&#10;&#10;  getPastVisits: async (enterpriseId: string): Promise&lt;Visit[]&gt; =&gt; {&#10;    const response = await api.get(`/visits/enterprise/${enterpriseId}/past`);&#10;    return response.data;&#10;  }&#10;};&#10;&#10;export default visitService;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/frontend/src/store/slices/authSlice.ts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/frontend/src/store/slices/authSlice.ts" />
              <option name="originalContent" value="import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';&#10;import authService from '../../services/authService';&#10;import { LoginCredentials, RegisterData, AuthResponse } from '../../types/auth';&#10;&#10;interface AuthState {&#10;  user: AuthResponse['user'] | null;&#10;  isAuthenticated: boolean;&#10;  loading: boolean;&#10;  error: string | null;&#10;}&#10;&#10;const initialState: AuthState = {&#10;  user: null,&#10;  isAuthenticated: false,&#10;  loading: false,&#10;  error: null&#10;};&#10;&#10;export const login = createAsyncThunk(&#10;  'auth/login',&#10;  async (credentials: LoginCredentials, { rejectWithValue }) =&gt; {&#10;    try {&#10;      const response = await authService.login(credentials);&#10;      return response;&#10;    } catch (error: any) {&#10;      const data = error.response?.data;&#10;      const msg = data?.message || (data?.errors &amp;&amp; Array.isArray(data.errors) ? data.errors.map((e: any) =&gt; e.msg).join(', ') : null) || 'Erreur de connexion';&#10;      return rejectWithValue(msg);&#10;    }&#10;  }&#10;);&#10;&#10;export const register = createAsyncThunk(&#10;  'auth/register',&#10;  async (data: RegisterData, { rejectWithValue }) =&gt; {&#10;    try {&#10;      const response = await authService.register(data);&#10;      return response;&#10;    } catch (error: any) {&#10;      const dataErr = error.response?.data;&#10;      const msg = dataErr?.message || (dataErr?.errors &amp;&amp; Array.isArray(dataErr.errors) ? dataErr.errors.map((e: any) =&gt; e.msg).join(', ') : null) || 'Erreur d\'inscription';&#10;      return rejectWithValue(msg);&#10;    }&#10;  }&#10;);&#10;&#10;const authSlice = createSlice({&#10;  name: 'auth',&#10;  initialState,&#10;  reducers: {&#10;    logout: (state) =&gt; {&#10;      authService.logout();&#10;      state.user = null;&#10;      state.isAuthenticated = false;&#10;    },&#10;    clearError: (state) =&gt; {&#10;      state.error = null;&#10;    },&#10;      })&#10;      .addCase(login.fulfilled, (state, action: PayloadAction&lt;AuthResponse&gt;) =&gt; {&#10;        state.loading = false;&#10;        state.user = action.payload.user;&#10;        state.isAuthenticated = true;&#10;      })&#10;      .addCase(login.rejected, (state, action) =&gt; {&#10;        state.loading = false;&#10;        state.error = action.payload as string;&#10;      })&#10;      .addCase(register.pending, (state) =&gt; {&#10;        state.loading = true;&#10;        state.error = null;&#10;      })&#10;      .addCase(register.fulfilled, (state, action: PayloadAction&lt;AuthResponse&gt;) =&gt; {&#10;        state.loading = false;&#10;        state.user = action.payload.user;&#10;        state.isAuthenticated = true;&#10;      })&#10;      .addCase(register.rejected, (state, action) =&gt; {&#10;        state.loading = false;&#10;        state.error = action.payload as string;&#10;      });&#10;  },&#10;});&#10;&#10;export const { logout, clearError } = authSlice.actions;&#10;export default authSlice.reducer;&#10;" />
              <option name="updatedContent" value="import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';&#10;import authService from '../../services/authService';&#10;import { LoginCredentials, RegisterData, AuthResponse } from '../../types/auth';&#10;&#10;interface AuthState {&#10;  user: AuthResponse['user'] | null;&#10;  isAuthenticated: boolean;&#10;  loading: boolean;&#10;  error: string | null;&#10;}&#10;&#10;const initialState: AuthState = {&#10;  user: null,&#10;  isAuthenticated: false,&#10;  loading: false,&#10;  error: null&#10;};&#10;&#10;export const login = createAsyncThunk(&#10;  'auth/login',&#10;  async (credentials: LoginCredentials, { rejectWithValue }) =&gt; {&#10;    try {&#10;      const response = await authService.login(credentials);&#10;      return response;&#10;    } catch (error: any) {&#10;      const data = error.response?.data;&#10;      const msg = data?.message || (data?.errors &amp;&amp; Array.isArray(data.errors) ? data.errors.map((e: any) =&gt; e.msg).join(', ') : null) || 'Erreur de connexion';&#10;      return rejectWithValue(msg);&#10;    }&#10;  }&#10;);&#10;&#10;export const register = createAsyncThunk(&#10;  'auth/register',&#10;  async (data: RegisterData, { rejectWithValue }) =&gt; {&#10;    try {&#10;      const response = await authService.register(data);&#10;      return response;&#10;    } catch (error: any) {&#10;      const dataErr = error.response?.data;&#10;      const msg = dataErr?.message || (dataErr?.errors &amp;&amp; Array.isArray(dataErr.errors) ? dataErr.errors.map((e: any) =&gt; e.msg).join(', ') : null) || 'Erreur d\'inscription';&#10;      return rejectWithValue(msg);&#10;    }&#10;  }&#10;);&#10;&#10;const authSlice = createSlice({&#10;  name: 'auth',&#10;  initialState,&#10;  reducers: {&#10;    logout: (state) =&gt; {&#10;      authService.logout();&#10;      state.user = null;&#10;      state.isAuthenticated = false;&#10;    },&#10;    clearError: (state) =&gt; {&#10;      state.error = null;&#10;    },&#10;    setUser: (state, action: PayloadAction&lt;AuthResponse['user']&gt;) =&gt; {&#10;      state.user = action.payload;&#10;      state.isAuthenticated = true;&#10;      state.loading = false;&#10;      state.error = null;&#10;    },&#10;  },&#10;  extraReducers: (builder) =&gt; {&#10;    builder&#10;      .addCase(login.pending, (state) =&gt; {&#10;        state.loading = true;&#10;        state.error = null;&#10;      })&#10;      .addCase(login.fulfilled, (state, action: PayloadAction&lt;AuthResponse&gt;) =&gt; {&#10;        state.loading = false;&#10;        state.user = action.payload.user;&#10;        state.isAuthenticated = true;&#10;      })&#10;      .addCase(login.rejected, (state, action) =&gt; {&#10;        state.loading = false;&#10;        state.error = action.payload as string;&#10;      })&#10;      .addCase(register.pending, (state) =&gt; {&#10;        state.loading = true;&#10;        state.error = null;&#10;      })&#10;      .addCase(register.fulfilled, (state, action: PayloadAction&lt;AuthResponse&gt;) =&gt; {&#10;        state.loading = false;&#10;        state.user = action.payload.user;&#10;        state.isAuthenticated = true;&#10;      })&#10;      .addCase(register.rejected, (state, action) =&gt; {&#10;        state.loading = false;&#10;        state.error = action.payload as string;&#10;      });&#10;  },&#10;});&#10;&#10;export const { logout, clearError, setUser } = authSlice.actions;&#10;export default authSlice.reducer;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/controllers/conventionController.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/controllers/conventionController.js" />
              <option name="updatedContent" value="const Convention = require('../models/Convention');&#10;const Enterprise = require('../models/Entreprise');&#10;&#10;exports.createConvention = async (req, res) =&gt; {&#10;  try {&#10;    const {&#10;      enterpriseId,&#10;      signedDate,&#10;      startDate,&#10;      endDate,&#10;      type,&#10;      advantages,&#10;      obligations&#10;    } = req.body;&#10;&#10;    // Verify enterprise exists&#10;    const enterprise = await Enterprise.findById(enterpriseId);&#10;    if (!enterprise) {&#10;      return res.status(404).json({ message: 'Enterprise not found' });&#10;    }&#10;&#10;    const convention = new Convention({&#10;      enterpriseId,&#10;      signedDate,&#10;      startDate,&#10;      endDate,&#10;      type,&#10;      advantages,&#10;      obligations,&#10;      metadata: {&#10;        createdBy: req.user._id,&#10;        lastModifiedBy: req.user._id&#10;      }&#10;    });&#10;&#10;    convention._lastModifiedBy = req.user._id;&#10;    convention.addHistoryEntry('CREATED', req.user._id, { type });&#10;    &#10;    await convention.save();&#10;    res.status(201).json(convention);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getConventionsByEnterprise = async (req, res) =&gt; {&#10;  try {&#10;    const { enterpriseId } = req.params;&#10;    const conventions = await Convention.find({ enterpriseId })&#10;      .populate('indicators')&#10;      .populate('documents')&#10;      .sort('-createdAt');&#10;    res.json(conventions);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getActiveConventions = async (req, res) =&gt; {&#10;  try {&#10;    const { enterpriseId } = req.params;&#10;    const conventions = await Convention.findActiveForEnterprise(enterpriseId)&#10;      .populate('indicators')&#10;      .populate('documents');&#10;    res.json(conventions);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.updateConvention = async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const updateData = req.body;&#10;    &#10;    const convention = await Convention.findById(id);&#10;    if (!convention) {&#10;      return res.status(404).json({ message: 'Convention not found' });&#10;    }&#10;&#10;    // Record what fields are being updated&#10;    const changes = {};&#10;    Object.keys(updateData).forEach(key =&gt; {&#10;      if (convention[key] !== updateData[key]) {&#10;        changes[key] = {&#10;          from: convention[key],&#10;          to: updateData[key]&#10;        };&#10;      }&#10;    });&#10;&#10;    convention._lastModifiedBy = req.user._id;&#10;    convention.addHistoryEntry('UPDATED', req.user._id, changes);&#10;&#10;    Object.assign(convention, updateData, {&#10;      'metadata.lastModifiedBy': req.user._id&#10;    });&#10;&#10;    await convention.save();&#10;    res.json(convention);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.updateConventionStatus = async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const { status } = req.body;&#10;&#10;    const convention = await Convention.findById(id);&#10;    if (!convention) {&#10;      return res.status(404).json({ message: 'Convention not found' });&#10;    }&#10;&#10;    const oldStatus = convention.status;&#10;    convention.status = status;&#10;    convention._lastModifiedBy = req.user._id;&#10;    convention.addHistoryEntry('STATUS_CHANGED', req.user._id, {&#10;      from: oldStatus,&#10;      to: status&#10;    });&#10;&#10;    await convention.save();&#10;    res.json(convention);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.addDocumentToConvention = async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const { documentId } = req.body;&#10;&#10;    const convention = await Convention.findById(id);&#10;    if (!convention) {&#10;      return res.status(404).json({ message: 'Convention not found' });&#10;    }&#10;&#10;    convention.documents.push(documentId);&#10;    convention._lastModifiedBy = req.user._id;&#10;    convention.addHistoryEntry('DOCUMENT_ADDED', req.user._id, { documentId });&#10;&#10;    await convention.save();&#10;    res.json(convention);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getConventionHistory = async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const convention = await Convention.findById(id)&#10;      .populate('history.userId', 'name email')&#10;      .select('history');&#10;    &#10;    if (!convention) {&#10;      return res.status(404).json({ message: 'Convention not found' });&#10;    }&#10;&#10;    res.json(convention.history);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getConventionSummary = async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const convention = await Convention.findById(id)&#10;      .populate('indicators', 'name currentValue targetValue status')&#10;      .populate('documents', 'name status uploadedAt')&#10;      .select('-history');&#10;&#10;    if (!convention) {&#10;      return res.status(404).json({ message: 'Convention not found' });&#10;    }&#10;&#10;    const summary = {&#10;      id: convention._id,&#10;      type: convention.type,&#10;      status: convention.status,&#10;      progress: {&#10;        documentsSubmitted: convention.documents.length,&#10;        indicatorsOnTrack: convention.indicators.filter(i =&gt; i.status === 'ON_TRACK').length,&#10;        totalIndicators: convention.indicators.length&#10;      },&#10;      startDate: convention.startDate,&#10;      endDate: convention.endDate,&#10;      daysRemaining: Math.ceil((convention.endDate - new Date()) / (1000 * 60 * 60 * 24))&#10;    };&#10;&#10;    res.json(summary);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/controllers/documentController.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/controllers/documentController.js" />
              <option name="updatedContent" value="const Document = require('../models/Document');&#10;const { uploadToS3, deleteFromS3 } = require('../utils/s3');&#10;&#10;exports.getCompanyDocuments = async (req, res) =&gt; {&#10;  try {&#10;    const documents = await Document.find({ enterpriseId: req.params.companyId })&#10;      .populate('validatedBy', 'name');&#10;    res.json(documents);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.uploadDocument = async (req, res) =&gt; {&#10;  try {&#10;    const { type } = req.body;&#10;    const file = req.file;&#10;    &#10;    if (!file) {&#10;      return res.status(400).json({ message: 'No file provided' });&#10;    }&#10;&#10;    // Upload file to S3&#10;    const uploadResult = await uploadToS3(file);&#10;&#10;    // Create document record&#10;    const document = new Document({&#10;      enterpriseId: req.params.companyId,&#10;      type,&#10;      files: [{&#10;        name: file.originalname,&#10;        url: uploadResult.Location&#10;      }],&#10;      uploadedAt: new Date(),&#10;      status: 'WAITING'&#10;    });&#10;&#10;    await document.save();&#10;    res.status(201).json(document);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.validateDocument = async (req, res) =&gt; {&#10;  try {&#10;    const { status, comment } = req.body;&#10;    const document = await Document.findById(req.params.id);&#10;&#10;    if (!document) {&#10;      return res.status(404).json({ message: 'Document not found' });&#10;    }&#10;&#10;    document.status = status;&#10;    document.comment = comment;&#10;    document.validatedBy = req.user.id;&#10;    document.validatedAt = new Date();&#10;&#10;    await document.save();&#10;    res.json(document);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.deleteDocument = async (req, res) =&gt; {&#10;  try {&#10;    const document = await Document.findById(req.params.id);&#10;    &#10;    if (!document) {&#10;      return res.status(404).json({ message: 'Document not found' });&#10;    }&#10;&#10;    // Delete files from S3&#10;    for (const file of document.files) {&#10;      await deleteFromS3(file.url);&#10;    }&#10;&#10;    await document.remove();&#10;    res.json({ message: 'Document deleted successfully' });&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getDocumentTypes = async (req, res) =&gt; {&#10;  try {&#10;    const types = Object.values(Document.schema.path('type').enumValues);&#10;    res.json(types);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/controllers/entrepriseController.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/controllers/entrepriseController.js" />
              <option name="originalContent" value="const Entreprise = require('../models/Entreprise');&#10;const { validationResult } = require('express-validator');&#10;&#10;// @desc    Obtenir toutes les entreprises&#10;// @route   GET /api/entreprises&#10;// @access  Private&#10;exports.getEntreprises = async (req, res) =&gt; {&#10;  try {&#10;    const entreprises = await Entreprise.find();&#10;    res.json(entreprises);&#10;  } catch (error) {&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Erreur lors de la récupération des entreprises',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// @desc    Obtenir une entreprise par ID&#10;// @route   GET /api/entreprises/:id&#10;// @access  Private&#10;exports.getEntreprise = async (req, res) =&gt; {&#10;  try {&#10;    const entreprise = await Entreprise.findById(req.params.id);&#10;    if (!entreprise) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Entreprise non trouvée'&#10;      });&#10;    }&#10;    res.json(entreprise);&#10;  } catch (error) {&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Erreur lors de la récupération de l\'entreprise',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// @desc    Créer une entreprise&#10;// @route   POST /api/entreprises&#10;// @access  Private/Admin&#10;exports.createEntreprise = async (req, res) =&gt; {&#10;  try {&#10;    const errors = validationResult(req);&#10;    if (!errors.isEmpty()) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        errors: errors.array()&#10;      });&#10;    }&#10;&#10;    const body = req.body || {};&#10;&#10;    // Build identification object (support nested identification or top-level fields)&#10;    const identificationFields = ['nomEntreprise','raisonSociale','region','ville','dateCreation','secteurActivite','sousSecteur','filiereProduction','formeJuridique','numeroContribuable'];&#10;    const identification = {};&#10;    if (body.identification &amp;&amp; typeof body.identification === 'object') {&#10;      identificationFields.forEach(f =&gt; {&#10;        if (body.identification[f] !== undefined) identification[f] = body.identification[f];&#10;      });&#10;    } else {&#10;      identificationFields.forEach(f =&gt; {&#10;        if (body[f] !== undefined) identification[f] = body[f];&#10;      });&#10;    }&#10;&#10;    const entrepriseData = {&#10;      identification,&#10;      performanceEconomique: body.performanceEconomique || {&#10;        chiffreAffaires: (body.chiffreAffaires || body['chiffreAffaires']) || undefined,&#10;        evolutionCA: undefined,&#10;        coutsProduction: undefined&#10;      },&#10;      investissementEmploi: body.investissementEmploi || undefined,&#10;      innovationDigitalisation: body.innovationDigitalisation || undefined,&#10;      conventions: body.conventions || undefined,&#10;      contact: body.contact || (body.telephone || body.email || body.siteWeb ? {&#10;        telephone: body.telephone || null,&#10;        email: body.email || undefined,&#10;        siteWeb: body.siteWeb || undefined,&#10;        adresse: body.adresse || undefined&#10;      } : undefined),&#10;      description: body.description || undefined,&#10;      documents: Array.isArray(body.documents) ? body.documents.map(d =&gt; ({&#10;        originalName: d.originalName || d.nom || d.filename || null,&#10;        filename: d.filename || null,&#10;        path: d.path || null,&#10;        mimeType: d.mimeType || d.mimetype || null,&#10;        size: d.size || null,&#10;        uploadedAt: d.uploadedAt || new Date(),&#10;        type: d.type || 'autre',&#10;        nom: d.nom || d.originalName || null&#10;      })) : []&#10;    };&#10;&#10;    const entreprise = await Entreprise.create(entrepriseData);&#10;&#10;    res.status(201).json({&#10;      success: true,&#10;      entreprise&#10;    });&#10;  } catch (error) {&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Erreur lors de la création de l\'entreprise',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// @desc    Mettre à jour une entreprise&#10;// @route   PUT /api/entreprises/:id&#10;// @access  Private&#10;exports.updateEntreprise = async (req, res) =&gt; {&#10;  try {&#10;    const errors = validationResult(req);&#10;    if (!errors.isEmpty()) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        errors: errors.array()&#10;      });&#10;    }&#10;&#10;    // Build nested update object only with provided fields&#10;    const body = req.body || {};&#10;    const updateData = {};&#10;&#10;    // Identification&#10;    const identificationFields = ['nomEntreprise','raisonSociale','region','ville','dateCreation','secteurActivite','sousSecteur','filiereProduction','formeJuridique','numeroContribuable'];&#10;    identificationFields.forEach(field =&gt; {&#10;      if (body[field] !== undefined) {&#10;        updateData[`identification.${field}`] = body[field];&#10;      }&#10;    });&#10;&#10;    // Performance Economique&#10;    if (body.performanceEconomique) {&#10;      // nested structure allowed&#10;      Object.keys(body.performanceEconomique).forEach(key =&gt; {&#10;        const val = body.performanceEconomique[key];&#10;        updateData[`performanceEconomique.${key}`] = val;&#10;      });&#10;    } else {&#10;      // allow flat CA fields&#10;      if (body['chiffreAffaires.montant'] !== undefined) updateData['performanceEconomique.chiffreAffaires.montant'] = body['chiffreAffaires.montant'];&#10;    }&#10;&#10;    // Investissement et Emploi&#10;    if (body.investissementEmploi) {&#10;      Object.keys(body.investissementEmploi).forEach(key =&gt; {&#10;        updateData[`investissementEmploi.${key}`] = body.investissementEmploi[key];&#10;      });&#10;    } else {&#10;      const invFields = ['effectifsEmployes','nouveauxEmploisCrees','nouveauxInvestissementsRealises','typesInvestissements'];&#10;      invFields.forEach(field =&gt; {&#10;        if (body[field] !== undefined) updateData[`investissementEmploi.${field}`] = body[field];&#10;      });&#10;    }&#10;&#10;    // Innovation et Digitalisation&#10;    if (body.innovationDigitalisation) {&#10;      Object.keys(body.innovationDigitalisation).forEach(key =&gt; {&#10;        updateData[`innovationDigitalisation.${key}`] = body.innovationDigitalisation[key];&#10;      });&#10;    }&#10;&#10;    // Conventions&#10;    if (body.conventions) {&#10;      Object.keys(body.conventions).forEach(key =&gt; {&#10;        // support nested objects like respectDelaisReporting.conforme&#10;        if (typeof body.conventions[key] === 'object' &amp;&amp; !Array.isArray(body.conventions[key])) {&#10;          Object.keys(body.conventions[key]).forEach(k2 =&gt; {&#10;            updateData[`conventions.${key}.${k2}`] = body.conventions[key][k2];&#10;          });&#10;        } else {&#10;          updateData[`conventions.${key}`] = body.conventions[key];&#10;        }&#10;      });&#10;    }&#10;&#10;    // Contact&#10;    if (body.contact) {&#10;      Object.keys(body.contact).forEach(key =&gt; {&#10;        if (typeof body.contact[key] === 'object' &amp;&amp; !Array.isArray(body.contact[key])) {&#10;          Object.keys(body.contact[key]).forEach(k2 =&gt; {&#10;            updateData[`contact.${key}.${k2}`] = body.contact[key][k2];&#10;          });&#10;        } else {&#10;          updateData[`contact.${key}`] = body.contact[key];&#10;        }&#10;      });&#10;    } else {&#10;      const contactFields = ['telephone','email','siteWeb'];&#10;      contactFields.forEach(field =&gt; {&#10;        if (body[field] !== undefined) updateData[`contact.${field}`] = body[field];&#10;      });&#10;    }&#10;&#10;    // Description&#10;    if (body.description !== undefined) updateData.description = body.description;&#10;&#10;" />
              <option name="updatedContent" value="const Entreprise = require('../models/Entreprise');&#10;const { validationResult } = require('express-validator');&#10;&#10;// @desc    Obtenir toutes les entreprises&#10;// @route   GET /api/entreprises&#10;// @access  Private&#10;exports.getEntreprises = async (req, res) =&gt; {&#10;  try {&#10;    const entreprises = await Entreprise.find();&#10;    res.json(entreprises);&#10;  } catch (error) {&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Erreur lors de la récupération des entreprises',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// @desc    Obtenir une entreprise par ID&#10;// @route   GET /api/entreprises/:id&#10;// @access  Private&#10;exports.getEntreprise = async (req, res) =&gt; {&#10;  try {&#10;    const entreprise = await Entreprise.findById(req.params.id);&#10;    if (!entreprise) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Entreprise non trouvée'&#10;      });&#10;    }&#10;    res.json(entreprise);&#10;  } catch (error) {&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Erreur lors de la récupération de l\'entreprise',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// @desc    Créer une entreprise&#10;// @route   POST /api/entreprises&#10;// @access  Private/Admin&#10;exports.createEntreprise = async (req, res) =&gt; {&#10;  try {&#10;    const errors = validationResult(req);&#10;    if (!errors.isEmpty()) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        errors: errors.array()&#10;      });&#10;    }&#10;&#10;    const body = req.body || {};&#10;&#10;    // Build identification object (support nested identification or top-level fields)&#10;    const identificationFields = ['nomEntreprise','raisonSociale','region','ville','dateCreation','secteurActivite','sousSecteur','filiereProduction','formeJuridique','numeroContribuable'];&#10;    const identification = {};&#10;    if (body.identification &amp;&amp; typeof body.identification === 'object') {&#10;      identificationFields.forEach(f =&gt; {&#10;        if (body.identification[f] !== undefined) identification[f] = body.identification[f];&#10;      });&#10;    } else {&#10;      identificationFields.forEach(f =&gt; {&#10;        if (body[f] !== undefined) identification[f] = body[f];&#10;      });&#10;    }&#10;&#10;    const entrepriseData = {&#10;      identification,&#10;      performanceEconomique: body.performanceEconomique || {&#10;        chiffreAffaires: (body.chiffreAffaires || body['chiffreAffaires']) || undefined,&#10;        evolutionCA: undefined,&#10;        coutsProduction: undefined&#10;      },&#10;      investissementEmploi: body.investissementEmploi || undefined,&#10;      innovationDigitalisation: body.innovationDigitalisation || undefined,&#10;      conventions: body.conventions || undefined,&#10;      contact: body.contact || (body.telephone || body.email || body.siteWeb ? {&#10;        telephone: body.telephone || null,&#10;        email: body.email || undefined,&#10;        siteWeb: body.siteWeb || undefined,&#10;        adresse: body.adresse || undefined&#10;      } : undefined),&#10;      description: body.description || undefined,&#10;      documents: Array.isArray(body.documents) ? body.documents.map(d =&gt; ({&#10;        originalName: d.originalName || d.nom || d.filename || null,&#10;        filename: d.filename || null,&#10;        path: d.path || null,&#10;        mimeType: d.mimeType || d.mimetype || null,&#10;        size: d.size || null,&#10;        uploadedAt: d.uploadedAt || new Date(),&#10;        type: d.type || 'autre',&#10;        nom: d.nom || d.originalName || null&#10;      })) : []&#10;    };&#10;&#10;    const entreprise = await Entreprise.create(entrepriseData);&#10;&#10;    res.status(201).json({&#10;      success: true,&#10;      entreprise&#10;    });&#10;  } catch (error) {&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Erreur lors de la création de l\'entreprise',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// @desc    Mettre à jour une entreprise&#10;// @route   PUT /api/entreprises/:id&#10;// @access  Private&#10;exports.updateEntreprise = async (req, res) =&gt; {&#10;  try {&#10;    const errors = validationResult(req);&#10;    if (!errors.isEmpty()) {&#10;      return res.status(400).json({&#10;        success: false,&#10;        errors: errors.array()&#10;      });&#10;    }&#10;&#10;    // Build nested update object only with provided fields&#10;    const body = req.body || {};&#10;    const updateData = {};&#10;&#10;    // Identification&#10;    const identificationFields = ['nomEntreprise','raisonSociale','region','ville','dateCreation','secteurActivite','sousSecteur','filiereProduction','formeJuridique','numeroContribuable'];&#10;    identificationFields.forEach(field =&gt; {&#10;      if (body[field] !== undefined) {&#10;        updateData[`identification.${field}`] = body[field];&#10;      }&#10;    });&#10;&#10;    // Performance Economique&#10;    if (body.performanceEconomique) {&#10;      // nested structure allowed&#10;      Object.keys(body.performanceEconomique).forEach(key =&gt; {&#10;        const val = body.performanceEconomique[key];&#10;        updateData[`performanceEconomique.${key}`] = val;&#10;      });&#10;    } else {&#10;      // allow flat CA fields&#10;      if (body['chiffreAffaires.montant'] !== undefined) updateData['performanceEconomique.chiffreAffaires.montant'] = body['chiffreAffaires.montant'];&#10;    }&#10;&#10;    // Investissement et Emploi&#10;    if (body.investissementEmploi) {&#10;      Object.keys(body.investissementEmploi).forEach(key =&gt; {&#10;        updateData[`investissementEmploi.${key}`] = body.investissementEmploi[key];&#10;      });&#10;    } else {&#10;      const invFields = ['effectifsEmployes','nouveauxEmploisCrees','nouveauxInvestissementsRealises','typesInvestissements'];&#10;      invFields.forEach(field =&gt; {&#10;        if (body[field] !== undefined) updateData[`investissementEmploi.${field}`] = body[field];&#10;      });&#10;    }&#10;&#10;    // Innovation et Digitalisation&#10;    if (body.innovationDigitalisation) {&#10;      Object.keys(body.innovationDigitalisation).forEach(key =&gt; {&#10;        updateData[`innovationDigitalisation.${key}`] = body.innovationDigitalisation[key];&#10;      });&#10;    }&#10;&#10;    // Conventions&#10;    if (body.conventions) {&#10;      Object.keys(body.conventions).forEach(key =&gt; {&#10;        // support nested objects like respectDelaisReporting.conforme&#10;        if (typeof body.conventions[key] === 'object' &amp;&amp; !Array.isArray(body.conventions[key])) {&#10;          Object.keys(body.conventions[key]).forEach(k2 =&gt; {&#10;            updateData[`conventions.${key}.${k2}`] = body.conventions[key][k2];&#10;          });&#10;        } else {&#10;          updateData[`conventions.${key}`] = body.conventions[key];&#10;        }&#10;      });&#10;    }&#10;&#10;    // Contact&#10;    if (body.contact) {&#10;      Object.keys(body.contact).forEach(key =&gt; {&#10;        if (typeof body.contact[key] === 'object' &amp;&amp; !Array.isArray(body.contact[key])) {&#10;          Object.keys(body.contact[key]).forEach(k2 =&gt; {&#10;            updateData[`contact.${key}.${k2}`] = body.contact[key][k2];&#10;          });&#10;        } else {&#10;          updateData[`contact.${key}`] = body.contact[key];&#10;        }&#10;      });&#10;    } else {&#10;      const contactFields = ['telephone','email','siteWeb'];&#10;      contactFields.forEach(field =&gt; {&#10;        if (body[field] !== undefined) updateData[`contact.${field}`] = body[field];&#10;      });&#10;    }&#10;&#10;    // Description&#10;    if (body.description !== undefined) updateData.description = body.description;&#10;&#10;    // Documents (replace whole documents array if provided)&#10;    if (body.documents !== undefined) {&#10;      updateData.documents = Array.isArray(body.documents)&#10;        ? body.documents.map(d =&gt; ({&#10;            originalName: d.originalName || d.nom || d.filename || null,&#10;            filename: d.filename || null,&#10;            path: d.path || null,&#10;            mimeType: d.mimeType || d.mimetype || null,&#10;            size: d.size || null,&#10;            uploadedAt: d.uploadedAt || new Date(),&#10;            type: d.type || 'autre',&#10;            nom: d.nom || d.originalName || null&#10;          }))&#10;        : body.documents;&#10;    }&#10;&#10;    // Update modification date&#10;    updateData.dateModification = new Date();&#10;&#10;    // Apply update&#10;    const entreprise = await Entreprise.findByIdAndUpdate(&#10;      req.params.id,&#10;      { $set: updateData },&#10;      { new: true }&#10;    );&#10;&#10;    if (!entreprise) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Entreprise non trouvée'&#10;      });&#10;    }&#10;&#10;    res.json({&#10;      success: true,&#10;      entreprise&#10;    });&#10;  } catch (error) {&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Erreur lors de la mise à jour de l\'entreprise',&#10;      error: error.message&#10;    });&#10;  }&#10;};&#10;&#10;// @desc    Supprimer une entreprise&#10;// @route   DELETE /api/entreprises/:id&#10;// @access  Private/Admin&#10;exports.deleteEntreprise = async (req, res) =&gt; {&#10;  try {&#10;    const entreprise = await Entreprise.findByIdAndDelete(req.params.id);&#10;&#10;    if (!entreprise) {&#10;      return res.status(404).json({&#10;        success: false,&#10;        message: 'Entreprise non trouvée'&#10;      });&#10;    }&#10;&#10;    res.json({&#10;      success: true,&#10;      message: 'Entreprise supprimée avec succès'&#10;    });&#10;  } catch (error) {&#10;    res.status(500).json({&#10;      success: false,&#10;      message: 'Erreur lors de la suppression de l\'entreprise',&#10;      error: error.message&#10;    });&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/controllers/indicatorController.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/controllers/indicatorController.js" />
              <option name="originalContent" value="const Indicator = require('../models/Indicator');&#10;const Convention = require('../models/Convention');&#10;&#10;exports.createIndicator = async (req, res) =&gt; {&#10;  try {&#10;    const {&#10;      conventionId,&#10;      name,&#10;      description,&#10;      type,&#10;      unit,&#10;      frequency,&#10;      targetValue,&#10;      minValue,&#10;      maxValue&#10;    } = req.body;&#10;&#10;    // Verify convention exists&#10;    const convention = await Convention.findById(conventionId);&#10;    if (!convention) {&#10;      return res.status(404).json({ message: 'Convention not found' });&#10;    }&#10;&#10;    const indicator = new Indicator({&#10;      conventionId,&#10;      name,&#10;      description,&#10;      type,&#10;      unit,&#10;      frequency,&#10;      targetValue,&#10;      minValue,&#10;      maxValue,&#10;      metadata: {&#10;        createdBy: req.user._id,&#10;        lastModifiedBy: req.user._id&#10;      }&#10;    });&#10;&#10;    await indicator.save();&#10;&#10;    // Add indicator reference to convention&#10;    convention.indicators.push(indicator._id);&#10;    await convention.save();&#10;&#10;    res.status(201).json(indicator);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getIndicatorsByConvention = async (req, res) =&gt; {&#10;  try {&#10;    const { conventionId } = req.params;&#10;    const indicators = await Indicator.find({ conventionId })&#10;      .populate('metadata.createdBy', 'name email')&#10;      .populate('metadata.lastModifiedBy', 'name email')&#10;      .sort('name');&#10;    res.json(indicators);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getIndicatorDetails = async (req, res) =&gt; {&#10;  try {&#10;    const indicator = await Indicator.findById(req.params.id)&#10;      .populate('history.submittedBy', 'name email')&#10;      .populate('metadata.createdBy', 'name email')&#10;      .populate('metadata.lastModifiedBy', 'name email');&#10;&#10;    if (!indicator) {&#10;      return res.status(404).json({ message: 'Indicator not found' });&#10;    }&#10;&#10;    res.json(indicator);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.updateIndicator = async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const updateData = req.body;&#10;&#10;    const indicator = await Indicator.findById(id);&#10;    if (!indicator) {&#10;      return res.status(404).json({ message: 'Indicator not found' });&#10;    }&#10;&#10;    Object.assign(indicator, updateData, {&#10;      'metadata.lastModifiedBy': req.user._id,&#10;      'metadata.updatedAt': new Date()&#10;    });&#10;&#10;    await indicator.save();&#10;    res.json(indicator);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.submitIndicatorValue = async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const { id } = req.params;&#10;    const indicator = await Indicator.findById(id);&#10;    const indicator = await Indicator.findById(id);&#10;    if (!indicator) {&#10;      return res.status(404).json({ message: 'Indicator not found' });&#10;    }&#10;&#10;    indicator.addHistoryEntry(value, req.user._id, attachments, comment);&#10;    await indicator.save();&#10;&#10;" />
              <option name="updatedContent" value="const Indicator = require('../models/Indicator');&#10;const Convention = require('../models/Convention');&#10;&#10;exports.createIndicator = async (req, res) =&gt; {&#10;  try {&#10;    const {&#10;      conventionId,&#10;      name,&#10;      description,&#10;      type,&#10;      unit,&#10;      frequency,&#10;      targetValue,&#10;      minValue,&#10;      maxValue&#10;    } = req.body;&#10;&#10;    // Verify convention exists&#10;    const convention = await Convention.findById(conventionId);&#10;    if (!convention) {&#10;      return res.status(404).json({ message: 'Convention not found' });&#10;    }&#10;&#10;    const indicator = new Indicator({&#10;      conventionId,&#10;      name,&#10;      description,&#10;      type,&#10;      unit,&#10;      frequency,&#10;      targetValue,&#10;      minValue,&#10;      maxValue,&#10;      metadata: {&#10;        createdBy: req.user._id,&#10;        lastModifiedBy: req.user._id&#10;      }&#10;    });&#10;&#10;    await indicator.save();&#10;&#10;    // Add indicator reference to convention&#10;    convention.indicators.push(indicator._id);&#10;    await convention.save();&#10;&#10;    res.status(201).json(indicator);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getIndicatorsByConvention = async (req, res) =&gt; {&#10;  try {&#10;    const { conventionId } = req.params;&#10;    const indicators = await Indicator.find({ conventionId })&#10;      .populate('metadata.createdBy', 'name email')&#10;      .populate('metadata.lastModifiedBy', 'name email')&#10;      .sort('name');&#10;    res.json(indicators);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getIndicatorDetails = async (req, res) =&gt; {&#10;  try {&#10;    const indicator = await Indicator.findById(req.params.id)&#10;      .populate('history.submittedBy', 'name email')&#10;      .populate('metadata.createdBy', 'name email')&#10;      .populate('metadata.lastModifiedBy', 'name email');&#10;&#10;    if (!indicator) {&#10;      return res.status(404).json({ message: 'Indicator not found' });&#10;    }&#10;&#10;    res.json(indicator);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.updateIndicator = async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const updateData = req.body;&#10;&#10;    const indicator = await Indicator.findById(id);&#10;    if (!indicator) {&#10;      return res.status(404).json({ message: 'Indicator not found' });&#10;    }&#10;&#10;    Object.assign(indicator, updateData, {&#10;      'metadata.lastModifiedBy': req.user._id,&#10;      'metadata.updatedAt': new Date()&#10;    });&#10;&#10;    await indicator.save();&#10;    res.json(indicator);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.submitIndicatorValue = async (req, res) =&gt; {&#10;  try {&#10;    const { value, comment, attachments } = req.body;&#10;    const indicator = await Indicator.findById(req.params.id)&#10;      .populate('conventionId', 'enterpriseId');&#10;&#10;    if (!indicator) {&#10;      return res.status(404).json({ message: 'Indicator not found' });&#10;    }&#10;&#10;    indicator.addHistoryEntry(value, req.user._id, attachments, comment);&#10;    await indicator.save();&#10;&#10;    // Get Socket.io instance&#10;    const io = req.app.get('io');&#10;    &#10;    // Emit to enterprise room&#10;    io.to(`enterprise_${indicator.conventionId.enterpriseId}`).emit('indicator:updated', {&#10;      type: 'VALUE_SUBMITTED',&#10;      indicatorId: indicator._id,&#10;      value,&#10;      submittedBy: req.user._id&#10;    });&#10;&#10;    // Emit to inspectors&#10;    io.to(`role_INSPECTOR`).emit('indicator:pending-validation', {&#10;      type: 'NEW_SUBMISSION',&#10;      indicatorId: indicator._id,&#10;      enterpriseId: indicator.conventionId.enterpriseId&#10;    });&#10;&#10;    res.json(indicator);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.validateIndicatorSubmission = async (req, res) =&gt; {&#10;  try {&#10;    const { id, submissionId } = req.params;&#10;    const { status, comment } = req.body;&#10;&#10;    const indicator = await Indicator.findById(id)&#10;      .populate('conventionId', 'enterpriseId');&#10;&#10;    if (!indicator) {&#10;      return res.status(404).json({ message: 'Indicator not found' });&#10;    }&#10;&#10;    const submission = indicator.history.id(submissionId);&#10;    if (!submission) {&#10;      return res.status(404).json({ message: 'Submission not found' });&#10;    }&#10;&#10;    submission.status = status;&#10;    if (comment) submission.comment = comment;&#10;    await indicator.save();&#10;&#10;    // Get Socket.io instance&#10;    const io = req.app.get('io');&#10;&#10;    // Emit validation result to enterprise&#10;    io.to(`enterprise_${indicator.conventionId.enterpriseId}`).emit('indicator:validated', {&#10;      type: 'SUBMISSION_VALIDATED',&#10;      indicatorId: indicator._id,&#10;      submissionId,&#10;      status,&#10;      validatedBy: req.user._id&#10;    });&#10;&#10;    res.json(indicator);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getIndicatorHistory = async (req, res) =&gt; {&#10;  try {&#10;    const { id } = req.params;&#10;    const indicator = await Indicator.findById(id)&#10;      .select('history')&#10;      .populate('history.submittedBy', 'name email');&#10;&#10;    if (!indicator) {&#10;      return res.status(404).json({ message: 'Indicator not found' });&#10;    }&#10;&#10;    res.json(indicator.history);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getIndicatorsReport = async (req, res) =&gt; {&#10;  try {&#10;    const { conventionId } = req.params;&#10;    const indicators = await Indicator.find({ conventionId })&#10;      .select('name type currentValue targetValue status nextReportingDate')&#10;      .sort('name');&#10;&#10;    const summary = {&#10;      total: indicators.length,&#10;      onTrack: indicators.filter(i =&gt; i.status === 'ON_TRACK').length,&#10;      atRisk: indicators.filter(i =&gt; i.status === 'AT_RISK').length,&#10;      offTrack: indicators.filter(i =&gt; i.status === 'OFF_TRACK').length,&#10;      notStarted: indicators.filter(i =&gt; i.status === 'NOT_STARTED').length,&#10;      indicators&#10;    };&#10;&#10;    res.json(summary);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/controllers/kpiController.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/controllers/kpiController.js" />
              <option name="updatedContent" value="const KPI = require('../models/KPI');&#10;&#10;exports.getKPIsByEnterprise = async (req, res) =&gt; {&#10;  try {&#10;    const kpis = await KPI.find({ enterpriseId: req.params.enterpriseId })&#10;      .populate('history.submittedBy', 'name');&#10;    res.json(kpis);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.submitKPIValue = async (req, res) =&gt; {&#10;  try {&#10;    const { value, comment } = req.body;&#10;    const kpi = await KPI.findById(req.params.kpiId);&#10;&#10;    if (!kpi) {&#10;      return res.status(404).json({ message: 'KPI not found' });&#10;    }&#10;&#10;    kpi.history.push({&#10;      value,&#10;      comment,&#10;      submittedBy: req.user.id,&#10;      date: new Date(),&#10;      status: 'pending'&#10;    });&#10;&#10;    await kpi.save();&#10;    res.json(kpi);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.validateKPISubmission = async (req, res) =&gt; {&#10;  try {&#10;    const { status, comment } = req.body;&#10;    const kpi = await KPI.findById(req.params.kpiId);&#10;&#10;    if (!kpi) {&#10;      return res.status(404).json({ message: 'KPI not found' });&#10;    }&#10;&#10;    const submission = kpi.history.id(req.params.submissionId);&#10;    if (!submission) {&#10;      return res.status(404).json({ message: 'Submission not found' });&#10;    }&#10;&#10;    submission.status = status;&#10;    if (comment) {&#10;      submission.comment = comment;&#10;    }&#10;&#10;    await kpi.save();&#10;    res.json(kpi);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getKPIHistory = async (req, res) =&gt; {&#10;  try {&#10;    const { period } = req.query;&#10;    const kpi = await KPI.findById(req.params.kpiId)&#10;      .populate('history.submittedBy', 'name');&#10;&#10;    if (!kpi) {&#10;      return res.status(404).json({ message: 'KPI not found' });&#10;    }&#10;&#10;    let history = kpi.history;&#10;&#10;    if (period) {&#10;      const startDate = new Date();&#10;      startDate.setMonth(startDate.getMonth() - parseInt(period));&#10;      history = history.filter(entry =&gt; entry.date &gt;= startDate);&#10;    }&#10;&#10;    res.json(history);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getKPIOverview = async (req, res) =&gt; {&#10;  try {&#10;    const kpis = await KPI.find({ &#10;      enterpriseId: req.params.enterpriseId,&#10;      'history.status': 'validated'&#10;    }).sort({ 'history.date': -1 });&#10;&#10;    const overview = kpis.map(kpi =&gt; {&#10;      const latestValue = kpi.history&#10;        .filter(h =&gt; h.status === 'validated')&#10;        .sort((a, b) =&gt; b.date - a.date)[0];&#10;&#10;      return {&#10;        name: kpi.name,&#10;        currentValue: latestValue?.value || 0,&#10;        targetValue: kpi.targetValue,&#10;        unit: kpi.unit,&#10;        status: latestValue?.value &gt;= kpi.targetValue ? 'achieved' : 'pending'&#10;      };&#10;    });&#10;&#10;    res.json(overview);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/controllers/monitoringController.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/controllers/monitoringController.js" />
              <option name="updatedContent" value="const systemMonitor = require('../utils/systemMonitor');&#10;const os = require('os');&#10;const fs = require('fs').promises;&#10;const path = require('path');&#10;&#10;async function getUploadDirStats() {&#10;    const uploadDir = path.join(__dirname, '..', 'uploads');&#10;    const stats = await fs.stat(uploadDir);&#10;    return {&#10;        size: stats.size,&#10;        files: (await fs.readdir(uploadDir)).length&#10;    };&#10;}&#10;&#10;exports.getSystemStats = async (req, res) =&gt; {&#10;    try {&#10;        const stats = systemMonitor.getStats();&#10;        res.json({&#10;            success: true,&#10;            data: stats&#10;        });&#10;    } catch (error) {&#10;        res.status(500).json({&#10;            success: false,&#10;            message: 'Erreur lors de la récupération des statistiques système'&#10;        });&#10;    }&#10;};&#10;&#10;exports.getStorageStats = async (req, res) =&gt; {&#10;    try {&#10;        const uploadStats = await getUploadDirStats();&#10;        res.json({&#10;            success: true,&#10;            data: {&#10;                uploadDirectory: uploadStats,&#10;                systemStorage: {&#10;                    total: os.totalmem(),&#10;                    free: os.freemem()&#10;                }&#10;            }&#10;        });&#10;    } catch (error) {&#10;        res.status(500).json({&#10;            success: false,&#10;            message: 'Erreur lors de la récupération des statistiques de stockage'&#10;        });&#10;    }&#10;};&#10;&#10;exports.getSecurityAlerts = async (req, res) =&gt; {&#10;    try {&#10;        // Pour l'instant, renvoie des données de base sur la sécurité&#10;        res.json({&#10;            success: true,&#10;            data: {&#10;                lastLogin: new Date(),&#10;                failedLoginAttempts: 0,&#10;                securityUpdatesAvailable: false,&#10;                activeUsers: systemMonitor.getStats().process.activeUsers || 0&#10;            }&#10;        });&#10;    } catch (error) {&#10;        res.status(500).json({&#10;            success: false,&#10;            message: 'Erreur lors de la récupération des alertes de sécurité'&#10;        });&#10;    }&#10;};&#10;&#10;exports.getBackupStatus = async (req, res) =&gt; {&#10;    try {&#10;        // Pour l'instant, renvoie un statut de sauvegarde basique&#10;        res.json({&#10;            success: true,&#10;            data: {&#10;                lastBackup: new Date(),&#10;                backupSize: 0,&#10;                status: 'success',&#10;                nextScheduledBackup: new Date(Date.now() + 24 * 60 * 60 * 1000)&#10;            }&#10;        });&#10;    } catch (error) {&#10;        res.status(500).json({&#10;            success: false,&#10;            message: 'Erreur lors de la récupération du statut des sauvegardes'&#10;        });&#10;    }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/controllers/reportController.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/controllers/reportController.js" />
              <option name="updatedContent" value="const reportService = require('../utils/reports/reportService');&#10;&#10;exports.generateReport = async (req, res) =&gt; {&#10;    try {&#10;        const { type, format, dateDebut, dateFin } = req.body;&#10;        const report = await reportService.generateReport(type, format, dateDebut, dateFin);&#10;        res.json({&#10;            success: true,&#10;            data: report&#10;        });&#10;    } catch (error) {&#10;        res.status(500).json({&#10;            success: false,&#10;            message: 'Erreur lors de la génération du rapport'&#10;        });&#10;    }&#10;};&#10;&#10;exports.getReportTypes = async (req, res) =&gt; {&#10;    try {&#10;        const types = [&#10;            {&#10;                id: 'entreprises',&#10;                name: 'Rapport des entreprises',&#10;                formats: ['pdf', 'excel']&#10;            },&#10;            {&#10;                id: 'utilisateurs',&#10;                name: 'Rapport des utilisateurs',&#10;                formats: ['pdf', 'excel']&#10;            },&#10;            {&#10;                id: 'kpis',&#10;                name: 'Rapport des KPIs',&#10;                formats: ['pdf', 'excel']&#10;            }&#10;        ];&#10;        &#10;        res.json({&#10;            success: true,&#10;            data: types&#10;        });&#10;    } catch (error) {&#10;        res.status(500).json({&#10;            success: false,&#10;            message: 'Erreur lors de la récupération des types de rapports'&#10;        });&#10;    }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/controllers/visitController.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/controllers/visitController.js" />
              <option name="updatedContent" value="const Visit = require('../models/Visit');&#10;const { uploadToS3 } = require('../utils/s3');&#10;&#10;exports.getVisitsByEnterprise = async (req, res) =&gt; {&#10;  try {&#10;    const visits = await Visit.find({ enterpriseId: req.params.enterpriseId })&#10;      .populate('inspectorId', 'name')&#10;      .sort({ scheduledAt: -1 });&#10;    res.json(visits);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.requestVisit = async (req, res) =&gt; {&#10;  try {&#10;    const { scheduledAt, type, comment } = req.body;&#10;&#10;    const visit = new Visit({&#10;      enterpriseId: req.params.enterpriseId,&#10;      scheduledAt,&#10;      type,&#10;      comment,&#10;      status: 'SCHEDULED'&#10;    });&#10;&#10;    await visit.save();&#10;    res.status(201).json(visit);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.cancelVisit = async (req, res) =&gt; {&#10;  try {&#10;    const { reason } = req.body;&#10;    const visit = await Visit.findById(req.params.id);&#10;&#10;    if (!visit) {&#10;      return res.status(404).json({ message: 'Visit not found' });&#10;    }&#10;&#10;    if (visit.status === 'COMPLETED') {&#10;      return res.status(400).json({ message: 'Cannot cancel a completed visit' });&#10;    }&#10;&#10;    visit.status = 'CANCELLED';&#10;    visit.cancellationReason = reason;&#10;    await visit.save();&#10;&#10;    res.json(visit);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.submitVisitReport = async (req, res) =&gt; {&#10;  try {&#10;    const { content, outcome } = req.body;&#10;    const files = req.files;&#10;&#10;    const visit = await Visit.findById(req.params.id);&#10;    if (!visit) {&#10;      return res.status(404).json({ message: 'Visit not found' });&#10;    }&#10;&#10;    const uploadedFiles = [];&#10;    if (files &amp;&amp; files.length &gt; 0) {&#10;      for (const file of files) {&#10;        const uploadResult = await uploadToS3(file);&#10;        uploadedFiles.push({&#10;          name: file.originalname,&#10;          url: uploadResult.Location&#10;        });&#10;      }&#10;    }&#10;&#10;    visit.report = {&#10;      content,&#10;      files: uploadedFiles,&#10;      submittedAt: new Date(),&#10;      submittedBy: req.user.id,&#10;      outcome&#10;    };&#10;    visit.status = 'COMPLETED';&#10;&#10;    await visit.save();&#10;    res.json(visit);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getUpcomingVisits = async (req, res) =&gt; {&#10;  try {&#10;    const visits = await Visit.find({&#10;      enterpriseId: req.params.enterpriseId,&#10;      status: 'SCHEDULED',&#10;      scheduledAt: { $gte: new Date() }&#10;    })&#10;    .populate('inspectorId', 'name')&#10;    .sort({ scheduledAt: 1 });&#10;&#10;    res.json(visits);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getPastVisits = async (req, res) =&gt; {&#10;  try {&#10;    const visits = await Visit.find({&#10;      enterpriseId: req.params.enterpriseId,&#10;      $or: [&#10;        { status: 'COMPLETED' },&#10;        { scheduledAt: { $lt: new Date() } }&#10;      ]&#10;    })&#10;    .populate('inspectorId', 'name')&#10;    .sort({ scheduledAt: -1 });&#10;&#10;    res.json(visits);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.assignInspector = async (req, res) =&gt; {&#10;  try {&#10;    const { inspectorId } = req.body;&#10;    const visit = await Visit.findById(req.params.id);&#10;&#10;    if (!visit) {&#10;      return res.status(404).json({ message: 'Visit not found' });&#10;    }&#10;&#10;    visit.inspectorId = inspectorId;&#10;    await visit.save();&#10;&#10;    res.json(visit);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getInspectorVisits = async (req, res) =&gt; {&#10;  try {&#10;    const visits = await Visit.find({ inspectorId: req.user._id })&#10;      .populate('enterpriseId', 'nom')&#10;      .sort({ scheduledAt: -1 });&#10;    res.json(visits);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.updateVisitStatus = async (req, res) =&gt; {&#10;  try {&#10;    const { status, outcome } = req.body;&#10;    const visit = await Visit.findById(req.params.id);&#10;&#10;    if (!visit) {&#10;      return res.status(404).json({ message: 'Visit not found' });&#10;    }&#10;&#10;    if (visit.inspectorId.toString() !== req.user._id.toString()) {&#10;      return res.status(403).json({ message: 'Not authorized to update this visit' });&#10;    }&#10;&#10;    visit.status = status;&#10;    if (outcome) {&#10;      visit.outcome = outcome;&#10;    }&#10;    &#10;    await visit.save();&#10;    res.json(visit);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};&#10;&#10;exports.getVisitDetails = async (req, res) =&gt; {&#10;  try {&#10;    const visit = await Visit.findById(req.params.id)&#10;      .populate('enterpriseId', 'nom adresse telephone email')&#10;      .populate('inspectorId', 'name email');&#10;&#10;    if (!visit) {&#10;      return res.status(404).json({ message: 'Visit not found' });&#10;    }&#10;&#10;    res.json(visit);&#10;  } catch (error) {&#10;    res.status(500).json({ message: error.message });&#10;  }&#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/middleware/indicatorValidation.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/middleware/indicatorValidation.js" />
              <option name="updatedContent" value="const Indicator = require('../models/Indicator');&#10;const Convention = require('../models/Convention');&#10;&#10;const validateIndicatorSubmission = async (req, res, next) =&gt; {&#10;  try {&#10;    const { value } = req.body;&#10;    const indicator = await Indicator.findById(req.params.id);&#10;&#10;    if (!indicator) {&#10;      return res.status(404).json({ message: 'Indicator not found' });&#10;    }&#10;&#10;    // Check if value is within min/max bounds&#10;    if (indicator.minValue !== undefined &amp;&amp; value &lt; indicator.minValue) {&#10;      return res.status(400).json({ &#10;        message: `Value cannot be less than ${indicator.minValue}` &#10;      });&#10;    }&#10;&#10;    if (indicator.maxValue !== undefined &amp;&amp; value &gt; indicator.maxValue) {&#10;      return res.status(400).json({ &#10;        message: `Value cannot be greater than ${indicator.maxValue}` &#10;      });&#10;    }&#10;&#10;    // Check if it's time for a new submission based on frequency&#10;    const lastSubmission = indicator.history[indicator.history.length - 1];&#10;    if (lastSubmission) {&#10;      const now = new Date();&#10;      const nextAllowedDate = indicator.calculateNextReportingDate();&#10;      &#10;      if (now &lt; nextAllowedDate) {&#10;        return res.status(400).json({&#10;          message: `Next submission allowed after ${nextAllowedDate.toLocaleDateString()}`,&#10;          nextReportingDate: nextAllowedDate&#10;        });&#10;      }&#10;    }&#10;&#10;    // Add indicator and convention to request for use in controller&#10;    req.indicator = indicator;&#10;    const convention = await Convention.findById(indicator.conventionId);&#10;    if (convention &amp;&amp; convention.status !== 'ACTIVE') {&#10;      return res.status(400).json({ &#10;        message: 'Cannot submit values for inactive convention' &#10;      });&#10;    }&#10;    req.convention = convention;&#10;&#10;    next();&#10;  } catch (error) {&#10;    next(error);&#10;  }&#10;};&#10;&#10;module.exports = { validateIndicatorSubmission };" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/middleware/monitoring.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/middleware/monitoring.js" />
              <option name="updatedContent" value="const systemMonitor = require('../utils/systemMonitor');&#10;&#10;const monitoringMiddleware = (req, res, next) =&gt; {&#10;    // Enregistrer le temps de début de la requête&#10;    const startTime = Date.now();&#10;&#10;    // Une fois la réponse envoyée&#10;    res.on('finish', () =&gt; {&#10;        systemMonitor.trackRequest(req, startTime);&#10;    });&#10;&#10;    next();&#10;};&#10;&#10;module.exports = monitoringMiddleware;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/middleware/roles.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/middleware/roles.js" />
              <option name="originalContent" value="const roles = {&#10;  ADMIN: 'ADMIN',&#10;  INSPECTOR: 'INSPECTOR',&#10;  ENTERPRISE: 'ENTERPRISE'&#10;" />
              <option name="updatedContent" value="const roles = {&#10;  ADMIN: 'ADMIN',&#10;  INSPECTOR: 'INSPECTOR',&#10;  ENTERPRISE: 'ENTERPRISE',&#10;  USER: 'USER'&#10;};&#10;&#10;// Role hierarchy - higher roles inherit permissions from lower roles&#10;const roleHierarchy = {&#10;  [roles.ADMIN]: [roles.INSPECTOR, roles.ENTERPRISE, roles.USER],&#10;  [roles.INSPECTOR]: [roles.USER],&#10;  [roles.ENTERPRISE]: [roles.USER],&#10;  [roles.USER]: []&#10;};&#10;&#10;// Detailed permissions mapping&#10;const permissions = {&#10;  conventions: {&#10;    create: [roles.ADMIN],&#10;    read: [roles.ADMIN, roles.INSPECTOR, roles.ENTERPRISE],&#10;    update: [roles.ADMIN],&#10;    delete: [roles.ADMIN],&#10;    validate: [roles.ADMIN, roles.INSPECTOR]&#10;  },&#10;  indicators: {&#10;    create: [roles.ADMIN],&#10;    read: [roles.ADMIN, roles.INSPECTOR, roles.ENTERPRISE],&#10;    update: [roles.ADMIN],&#10;    submit: [roles.ENTERPRISE],&#10;    validate: [roles.INSPECTOR, roles.ADMIN]&#10;  },&#10;  documents: {&#10;    upload: [roles.ENTERPRISE],&#10;    read: [roles.ADMIN, roles.INSPECTOR, roles.ENTERPRISE],&#10;    validate: [roles.INSPECTOR, roles.ADMIN],&#10;    delete: [roles.ADMIN]&#10;  },&#10;  visits: {&#10;    schedule: [roles.ADMIN, roles.INSPECTOR],&#10;    read: [roles.ADMIN, roles.INSPECTOR, roles.ENTERPRISE],&#10;    report: [roles.INSPECTOR],&#10;    cancel: [roles.ADMIN, roles.INSPECTOR]&#10;  },&#10;  enterprises: {&#10;    create: [roles.ADMIN],&#10;    read: [roles.ADMIN, roles.INSPECTOR],&#10;    update: [roles.ADMIN],&#10;    delete: [roles.ADMIN]&#10;  }&#10;};&#10;&#10;// Check if a role has permission including inherited permissions&#10;const hasPermission = (userRole, resource, action) =&gt; {&#10;  if (!permissions[resource] || !permissions[resource][action]) {&#10;    return false;&#10;  }&#10;&#10;  const allowedRoles = permissions[resource][action];&#10;  const inheritedRoles = roleHierarchy[userRole] || [];&#10;  &#10;  return allowedRoles.includes(userRole) || &#10;         inheritedRoles.some(role =&gt; allowedRoles.includes(role));&#10;};&#10;&#10;// Middleware to check role&#10;const checkRole = (...allowedRoles) =&gt; {&#10;  return (req, res, next) =&gt; {&#10;    if (!req.user) {&#10;      return res.status(401).json({ message: 'Unauthorized' });&#10;    }&#10;&#10;    const hasRole = allowedRoles.some(role =&gt; &#10;      req.user.role === role || (roleHierarchy[req.user.role] || []).includes(role)&#10;    );&#10;&#10;    if (!hasRole) {&#10;      return res.status(403).json({ &#10;        message: 'Forbidden - Insufficient role',&#10;        required: allowedRoles,&#10;        current: req.user.role&#10;      });&#10;    }&#10;&#10;    next();&#10;  };&#10;};&#10;&#10;// Middleware to check specific permission&#10;const checkPermission = (resource, action) =&gt; {&#10;  return (req, res, next) =&gt; {&#10;    if (!req.user) {&#10;      return res.status(401).json({ message: 'Unauthorized' });&#10;    }&#10;&#10;    if (!hasPermission(req.user.role, resource, action)) {&#10;      return res.status(403).json({ &#10;        message: 'Forbidden - Insufficient permissions',&#10;        required: { resource, action },&#10;        current: req.user.role&#10;      });&#10;    }&#10;&#10;    next();&#10;  };&#10;};&#10;&#10;// Helper to check multiple permissions at once&#10;const checkMultiplePermissions = (permissions) =&gt; {&#10;  return (req, res, next) =&gt; {&#10;    if (!req.user) {&#10;      return res.status(401).json({ message: 'Unauthorized' });&#10;    }&#10;&#10;    const hasAllPermissions = permissions.every(({ resource, action }) =&gt; &#10;      hasPermission(req.user.role, resource, action)&#10;    );&#10;&#10;    if (!hasAllPermissions) {&#10;      return res.status(403).json({ &#10;        message: 'Forbidden - Insufficient permissions',&#10;        required: permissions,&#10;        current: req.user.role&#10;      });&#10;    }&#10;&#10;    next();&#10;  };&#10;};&#10;&#10;module.exports = { &#10;  roles, &#10;  permissions, &#10;  checkRole, &#10;  checkPermission, &#10;  checkMultiplePermissions,&#10;  hasPermission &#10;};" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/models/AuditLog.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/models/AuditLog.js" />
              <option name="updatedContent" value="const mongoose = require('mongoose');&#10;&#10;const auditLogSchema = new mongoose.Schema({&#10;  timestamp: {&#10;    type: Date,&#10;    default: Date.now,&#10;    required: true&#10;  },&#10;  userId: {&#10;    type: mongoose.Schema.Types.ObjectId,&#10;    ref: 'User',&#10;    required: true&#10;  },&#10;  action: {&#10;    type: String,&#10;    enum: ['CREATE', 'UPDATE', 'DELETE', 'LOGIN', 'LOGOUT', 'EXPORT'],&#10;    required: true&#10;  },&#10;  entityType: {&#10;    type: String,&#10;    enum: ['USER', 'ENTERPRISE', 'KPI', 'DOCUMENT', 'REPORT'],&#10;    required: true&#10;  },&#10;  entityId: {&#10;    type: String,&#10;    required: true&#10;  },&#10;  changes: {&#10;    type: mongoose.Schema.Types.Mixed,&#10;    required: true&#10;  },&#10;  ipAddress: String,&#10;  userAgent: String&#10;});&#10;&#10;// Index pour améliorer les performances des requêtes&#10;auditLogSchema.index({ timestamp: -1 });&#10;auditLogSchema.index({ userId: 1 });&#10;auditLogSchema.index({ entityType: 1, entityId: 1 });&#10;&#10;module.exports = mongoose.model('AuditLog', auditLogSchema);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/models/Convention.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/models/Convention.js" />
              <option name="updatedContent" value="const mongoose = require('mongoose');&#10;&#10;const conventionSchema = new mongoose.Schema({&#10;  enterpriseId: {&#10;    type: mongoose.Schema.Types.ObjectId,&#10;    ref: 'Entreprise',&#10;    required: true&#10;  },&#10;  signedDate: {&#10;    type: Date,&#10;    required: true&#10;  },&#10;  startDate: {&#10;    type: Date,&#10;    required: true&#10;  },&#10;  endDate: {&#10;    type: Date,&#10;    required: true&#10;  },&#10;  status: {&#10;    type: String,&#10;    enum: ['DRAFT', 'ACTIVE', 'EXPIRED', 'TERMINATED'],&#10;    default: 'DRAFT'&#10;  },&#10;  type: {&#10;    type: String,&#10;    required: true,&#10;    enum: ['INVESTMENT', 'EXPORT', 'INNOVATION', 'OTHER']&#10;  },&#10;  advantages: [{&#10;    type: {&#10;      type: String,&#10;      required: true,&#10;      enum: ['TAX_RELIEF', 'CUSTOMS_EXEMPTION', 'FINANCIAL_AID', 'OTHER']&#10;    },&#10;    description: String,&#10;    validUntil: Date,&#10;    conditions: String&#10;  }],&#10;  obligations: [{&#10;    type: {&#10;      type: String,&#10;      required: true,&#10;      enum: ['INVESTMENT_COMMITMENT', 'JOB_CREATION', 'EXPORT_QUOTA', 'REPORTING', 'OTHER']&#10;    },&#10;    description: String,&#10;    targetValue: Number,&#10;    deadline: Date,&#10;    unit: String&#10;  }],&#10;  indicators: [{&#10;    type: mongoose.Schema.Types.ObjectId,&#10;    ref: 'Indicator'&#10;  }],&#10;  documents: [{&#10;    type: mongoose.Schema.Types.ObjectId,&#10;    ref: 'Document'&#10;  }],&#10;  history: [{&#10;    action: {&#10;      type: String,&#10;      enum: ['CREATED', 'UPDATED', 'STATUS_CHANGED', 'DOCUMENT_ADDED', 'INDICATOR_UPDATED']&#10;    },&#10;    date: {&#10;      type: Date,&#10;      default: Date.now&#10;    },&#10;    userId: {&#10;      type: mongoose.Schema.Types.ObjectId,&#10;      ref: 'User'&#10;    },&#10;    details: mongoose.Schema.Types.Mixed&#10;  }],&#10;  metadata: {&#10;    createdBy: {&#10;      type: mongoose.Schema.Types.ObjectId,&#10;      ref: 'User'&#10;    },&#10;    lastModifiedBy: {&#10;      type: mongoose.Schema.Types.ObjectId,&#10;      ref: 'User'&#10;    }&#10;  }&#10;}, {&#10;  timestamps: true&#10;});&#10;&#10;// Middleware to update lastModifiedBy&#10;conventionSchema.pre('save', function(next) {&#10;  if (this.isModified()) {&#10;    this.metadata.lastModifiedBy = this._lastModifiedBy;&#10;  }&#10;  next();&#10;});&#10;&#10;// Method to add history entry&#10;conventionSchema.methods.addHistoryEntry = function(action, userId, details) {&#10;  this.history.push({&#10;    action,&#10;    userId,&#10;    details,&#10;    date: new Date()&#10;  });&#10;};&#10;&#10;// Method to check if convention is active&#10;conventionSchema.methods.isActive = function() {&#10;  const now = new Date();&#10;  return this.status === 'ACTIVE' &amp;&amp; &#10;         now &gt;= this.startDate &amp;&amp; &#10;         now &lt;= this.endDate;&#10;};&#10;&#10;// Static method to find active conventions for an enterprise&#10;conventionSchema.statics.findActiveForEnterprise = function(enterpriseId) {&#10;  const now = new Date();&#10;  return this.find({&#10;    enterpriseId,&#10;    status: 'ACTIVE',&#10;    startDate: { $lte: now },&#10;    endDate: { $gte: now }&#10;  });&#10;};&#10;&#10;module.exports = mongoose.model('Convention', conventionSchema);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/models/Document.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/models/Document.js" />
              <option name="updatedContent" value="const mongoose = require('mongoose');&#10;&#10;const documentSchema = new mongoose.Schema({&#10;  enterpriseId: {&#10;    type: mongoose.Schema.Types.ObjectId,&#10;    ref: 'Entreprise',&#10;    required: true&#10;  },&#10;  type: {&#10;    type: String,&#10;    required: true,&#10;    enum: ['BUSINESS_PLAN', 'FINANCIAL_STATEMENT', 'TAX_CERTIFICATE', 'SOCIAL_SECURITY', 'TRADE_REGISTER']&#10;  },&#10;  required: {&#10;    type: Boolean,&#10;    default: true&#10;  },&#10;  dueDate: {&#10;    type: Date,&#10;    required: true&#10;  },&#10;  status: {&#10;    type: String,&#10;    enum: ['RECEIVED', 'WAITING', 'EXPIRED', 'UPDATE_REQUIRED', 'VALIDATED'],&#10;    default: 'WAITING'&#10;  },&#10;  files: [{&#10;    name: String,&#10;    url: String,&#10;    uploadedAt: Date&#10;  }],&#10;  uploadedAt: Date,&#10;  validatedBy: {&#10;    type: mongoose.Schema.Types.ObjectId,&#10;    ref: 'User'&#10;  },&#10;  validatedAt: Date,&#10;  comment: String&#10;}, {&#10;  timestamps: true&#10;});&#10;&#10;documentSchema.index({ enterpriseId: 1, type: 1 });&#10;documentSchema.index({ status: 1 });&#10;documentSchema.index({ dueDate: 1 });&#10;&#10;module.exports = mongoose.model('Document', documentSchema);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/models/Entreprise.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/models/Entreprise.js" />
              <option name="originalContent" value="const mongoose = require('mongoose');&#10;&#10;const entrepriseSchema = new mongoose.Schema({&#10;  // 1. Indicateurs d'Identification et Structure de l'Entreprise&#10;  identification: {&#10;    nomEntreprise: {&#10;      type: String,&#10;      required: [true, 'Le nom de l\'entreprise est requis'],&#10;      trim: true,&#10;      maxlength: [200, 'Le nom ne peut pas dépasser 200 caractères']&#10;    },&#10;    raisonSociale: {&#10;      type: String,&#10;      trim: true,&#10;      maxlength: [200, 'La raison sociale ne peut pas dépasser 200 caractères']&#10;    },&#10;    region: {&#10;      type: String,&#10;      required: [true, 'La région est requise'],&#10;      trim: true,&#10;      enum: [&#10;        'Adamaoua', 'Centre', 'Est', 'Extrême-Nord', 'Littoral', &#10;        'Nord', 'Nord-Ouest', 'Ouest', 'Sud', 'Sud-Ouest'&#10;      ]&#10;    },&#10;    ville: {&#10;      type: String,&#10;      required: [true, 'La ville est requise'],&#10;      trim: true,&#10;      maxlength: [100, 'La ville ne peut pas dépasser 100 caractères']&#10;    },&#10;    dateCreation: {&#10;      type: Date,&#10;      required: [true, 'La date de création est requise']&#10;    },&#10;    secteurActivite: {&#10;      type: String,&#10;      required: [true, 'Le secteur d\'activité est requis'],&#10;      enum: [&#10;        'Primaire', 'Secondaire', 'Tertiaire'&#10;      ]&#10;    },&#10;    sousSecteur: {&#10;      type: String,&#10;      required: [true, 'Le sous-secteur est requis'],&#10;      enum: [&#10;        'Agro-industriel', 'Forêt-Bois', 'Mines', 'Pétrole-Gaz',&#10;        'Industrie manufacturière', 'BTP', 'Énergie', 'Eau',&#10;        'Commerce', 'Transport', 'Télécommunications', 'Banque-Assurance',&#10;        'Tourisme', 'Santé', 'Éducation', 'Autres'&#10;      ]&#10;    },&#10;    filiereProduction: {&#10;      type: String,&#10;      trim: true,&#10;      maxlength: [100, 'La filière de production ne peut pas dépasser 100 caractères']&#10;    },&#10;    formeJuridique: {&#10;      type: String,&#10;      required: [true, 'La forme juridique est requise'],&#10;      enum: [&#10;        'SARL', 'SA', 'EI', 'SUARL', 'SARLU', 'SNC', 'SCS', 'SAS', 'Autres'&#10;      ]&#10;    },&#10;    numeroContribuable: {&#10;      type: String,&#10;      required: [true, 'Le numéro de contribuable est requis'],&#10;      trim: true,&#10;      unique: true,&#10;      match: [/^[A-Z0-9]+$/, 'Le numéro de contribuable doit être alphanumérique']&#10;    }&#10;  },&#10;&#10;  // 2. Indicateurs de Performance Économique et Financière&#10;  performanceEconomique: {&#10;    chiffreAffaires: {&#10;      montant: {&#10;        type: Number,&#10;        min: [0, 'Le chiffre d\'affaires ne peut pas être négatif']&#10;      },&#10;      devise: {&#10;        type: String,&#10;        enum: ['FCFA', 'USD', 'EUR'],&#10;        default: 'FCFA'&#10;      },&#10;      periode: {&#10;        type: String,&#10;        enum: ['Trimestre 1', 'Trimestre 2', 'Trimestre 3', 'Trimestre 4', 'Année complète']&#10;      }&#10;    },&#10;    evolutionCA: {&#10;      type: String,&#10;      enum: ['Hausse', 'Baisse', 'Stabilité']&#10;    },&#10;    coutsProduction: {&#10;      montant: {&#10;        type: Number,&#10;        min: [0, 'Les coûts de production ne peuvent pas être négatifs']&#10;      },&#10;      devise: {&#10;        type: String,&#10;        enum: ['FCFA', 'USD', 'EUR'],&#10;        default: 'FCFA'&#10;      }&#10;    },&#10;    evolutionCouts: {&#10;      type: String,&#10;      enum: ['Accroissement', 'Baisse', 'Stabilité']&#10;    },&#10;    situationTresorerie: {&#10;      type: String,&#10;      enum: ['Difficile', 'Normale', 'Aisée']&#10;    },&#10;    sourcesFinancement: {&#10;      ressourcesPropres: { type: Boolean, default: false },&#10;      subventions: { type: Boolean, default: false },&#10;      concoursBancaires: { type: Boolean, default: false },&#10;      creditsFournisseur: { type: Boolean, default: false },&#10;      autres: { type: Boolean, default: false },&#10;      autresDetails: {&#10;        type: String,&#10;        trim: true,&#10;        maxlength: [200, 'Les détails ne peuvent pas dépasser 200 caractères']&#10;      }&#10;    }&#10;  },&#10;&#10;  // 3. Indicateurs d'Investissement et d'Emploi&#10;  investissementEmploi: {&#10;    effectifsEmployes: {&#10;      type: Number,&#10;      required: [true, 'Le nombre d\'employés est requis'],&#10;      min: [0, 'Le nombre d\'employés ne peut pas être négatif']&#10;    },&#10;    nouveauxEmploisCrees: {&#10;      type: Number,&#10;      default: 0,&#10;      min: [0, 'Le nombre de nouveaux emplois ne peut pas être négatif']&#10;    },&#10;    nouveauxInvestissementsRealises: {&#10;      type: Boolean,&#10;      default: false&#10;    },&#10;    typesInvestissements: {&#10;      immobiliers: { type: Boolean, default: false },&#10;      mobiliers: { type: Boolean, default: false },&#10;      incorporels: { type: Boolean, default: false },&#10;      financiers: { type: Boolean, default: false }&#10;    }&#10;  },&#10;&#10;  // 4. Indicateurs d'Innovation et de Digitalisation&#10;  innovationDigitalisation: {&#10;    integrationInnovation: {&#10;      type: Number,&#10;      min: 1,&#10;      max: 3,&#10;      default: 1&#10;    },&#10;    integrationEconomieNumerique: {&#10;      type: Number,&#10;      min: 1,&#10;      max: 3,&#10;      default: 1&#10;    },&#10;    utilisationIA: {&#10;      type: Number,&#10;      min: 1,&#10;      max: 3,&#10;      default: 1&#10;    }&#10;  },&#10;&#10;  // 5. Indicateurs liés aux Conventions&#10;  conventions: {&#10;    respectDelaisReporting: {&#10;      conforme: { type: Boolean, default: true },&#10;      joursRetard: { type: Number, default: 0, min: 0 }&#10;    },&#10;    atteinteCiblesInvestissement: {&#10;      type: Number,&#10;      min: 0,&#10;      max: 100,&#10;      default: 0&#10;    },&#10;    atteinteCiblesEmploi: {&#10;      type: Number,&#10;      min: 0,&#10;      max: 100,&#10;      default: 0&#10;    },&#10;    conformiteNormesSpecifiques: {&#10;      conforme: { type: Boolean, default: true },&#10;      niveauConformite: {&#10;        type: Number,&#10;        min: 1,&#10;        max: 5,&#10;        default: 5&#10;      }&#10;    }&#10;  },&#10;&#10;  // Informations de contact&#10;  contact: {&#10;    telephone: {&#10;      type: String,&#10;      required: false,&#10;      trim: true,&#10;      default: null,&#10;      validate: {&#10;        validator: function(v) {&#10;          // Only validate format when a value is provided&#10;          if (v === null || v === undefined || v === '') return true;&#10;          return /^[0-9+\-\s()]+$/.test(v);&#10;        },&#10;        message: 'Veuillez entrer un numéro de téléphone valide'&#10;      }&#10;    },&#10;    email: {&#10;      type: String,&#10;      required: [true, 'L\'email est requis'],&#10;      lowercase: true,&#10;      trim: true,&#10;      match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Veuillez entrer un email valide']&#10;    },&#10;    siteWeb: {&#10;      type: String,&#10;      trim: true,&#10;      match: [/^https?:\/\/.+/, 'Veuillez entrer une URL valide']&#10;    },&#10;    adresse: {&#10;      rue: {&#10;        type: String,&#10;        trim: true,&#10;        maxlength: [200, 'L\'adresse ne peut pas dépasser 200 caractères']&#10;      },&#10;      ville: {&#10;        type: String,&#10;        trim: true,&#10;        maxlength: [100, 'La ville ne peut pas dépasser 100 caractères']&#10;      },&#10;      codePostal: {&#10;        type: String,&#10;        trim: true,&#10;        maxlength: [10, 'Le code postal ne peut pas dépasser 10 caractères']&#10;      },&#10;      pays: {&#10;        type: String,&#10;        trim: true,&#10;        maxlength: [50, 'Le pays ne peut pas dépasser 50 caractères'],&#10;        default: 'Cameroun'&#10;      }&#10;    }&#10;  },&#10;&#10;  // Statut et métadonnées&#10;  statut: {&#10;    type: String,&#10;    enum: ['En attente', 'Actif', 'Inactif', 'Suspendu'],&#10;    default: 'En attente'&#10;  },&#10;  informationsCompletes: {&#10;    type: Boolean,&#10;    default: false&#10;  },&#10;  dateCreation: {&#10;    type: Date,&#10;    default: Date.now&#10;  },&#10;  dateModification: {&#10;    type: Date,&#10;    default: Date.now&#10;  },&#10;  description: {&#10;    type: String,&#10;    trim: true,&#10;    maxlength: [1000, 'La description ne peut pas dépasser 1000 caractères']&#10;  }&#10;}, {&#10;  timestamps: true&#10;" />
              <option name="updatedContent" value="const mongoose = require('mongoose');&#10;&#10;const entrepriseSchema = new mongoose.Schema({&#10;  // 1. Indicateurs d'Identification et Structure de l'Entreprise&#10;  identification: {&#10;    nomEntreprise: {&#10;      type: String,&#10;      required: [true, 'Le nom de l\'entreprise est requis'],&#10;      trim: true,&#10;      maxlength: [200, 'Le nom ne peut pas dépasser 200 caractères']&#10;    },&#10;    raisonSociale: {&#10;      type: String,&#10;      trim: true,&#10;      maxlength: [200, 'La raison sociale ne peut pas dépasser 200 caractères']&#10;    },&#10;    region: {&#10;      type: String,&#10;      required: [true, 'La région est requise'],&#10;      trim: true,&#10;      enum: [&#10;        'Adamaoua', 'Centre', 'Est', 'Extrême-Nord', 'Littoral', &#10;        'Nord', 'Nord-Ouest', 'Ouest', 'Sud', 'Sud-Ouest'&#10;      ]&#10;    },&#10;    ville: {&#10;      type: String,&#10;      required: [true, 'La ville est requise'],&#10;      trim: true,&#10;      maxlength: [100, 'La ville ne peut pas dépasser 100 caractères']&#10;    },&#10;    dateCreation: {&#10;      type: Date,&#10;      required: [true, 'La date de création est requise']&#10;    },&#10;    secteurActivite: {&#10;      type: String,&#10;      required: [true, 'Le secteur d\'activité est requis'],&#10;      enum: [&#10;        'Primaire', 'Secondaire', 'Tertiaire'&#10;      ]&#10;    },&#10;    sousSecteur: {&#10;      type: String,&#10;      required: [true, 'Le sous-secteur est requis'],&#10;      enum: [&#10;        'Agro-industriel', 'Forêt-Bois', 'Mines', 'Pétrole-Gaz',&#10;        'Industrie manufacturière', 'BTP', 'Énergie', 'Eau',&#10;        'Commerce', 'Transport', 'Télécommunications', 'Banque-Assurance',&#10;        'Tourisme', 'Santé', 'Éducation', 'Autres'&#10;      ]&#10;    },&#10;    filiereProduction: {&#10;      type: String,&#10;      trim: true,&#10;      maxlength: [100, 'La filière de production ne peut pas dépasser 100 caractères']&#10;    },&#10;    formeJuridique: {&#10;      type: String,&#10;      required: [true, 'La forme juridique est requise'],&#10;      enum: [&#10;        'SARL', 'SA', 'EI', 'SUARL', 'SARLU', 'SNC', 'SCS', 'SAS', 'Autres'&#10;      ]&#10;    },&#10;    numeroContribuable: {&#10;      type: String,&#10;      required: [true, 'Le numéro de contribuable est requis'],&#10;      trim: true,&#10;      unique: true,&#10;      match: [/^[A-Z0-9]+$/, 'Le numéro de contribuable doit être alphanumérique']&#10;    }&#10;  },&#10;&#10;  // 2. Indicateurs de Performance Économique et Financière&#10;  performanceEconomique: {&#10;    chiffreAffaires: {&#10;      montant: {&#10;        type: Number,&#10;        min: [0, 'Le chiffre d\'affaires ne peut pas être négatif']&#10;      },&#10;      devise: {&#10;        type: String,&#10;        enum: ['FCFA', 'USD', 'EUR'],&#10;        default: 'FCFA'&#10;      },&#10;      periode: {&#10;        type: String,&#10;        enum: ['Trimestre 1', 'Trimestre 2', 'Trimestre 3', 'Trimestre 4', 'Année complète']&#10;      }&#10;    },&#10;    evolutionCA: {&#10;      type: String,&#10;      enum: ['Hausse', 'Baisse', 'Stabilité']&#10;    },&#10;    coutsProduction: {&#10;      montant: {&#10;        type: Number,&#10;        min: [0, 'Les coûts de production ne peuvent pas être négatifs']&#10;      },&#10;      devise: {&#10;        type: String,&#10;        enum: ['FCFA', 'USD', 'EUR'],&#10;        default: 'FCFA'&#10;      }&#10;    },&#10;    evolutionCouts: {&#10;      type: String,&#10;      enum: ['Accroissement', 'Baisse', 'Stabilité']&#10;    },&#10;    situationTresorerie: {&#10;      type: String,&#10;      enum: ['Difficile', 'Normale', 'Aisée']&#10;    },&#10;    sourcesFinancement: {&#10;      ressourcesPropres: { type: Boolean, default: false },&#10;      subventions: { type: Boolean, default: false },&#10;      concoursBancaires: { type: Boolean, default: false },&#10;      creditsFournisseur: { type: Boolean, default: false },&#10;      autres: { type: Boolean, default: false },&#10;      autresDetails: {&#10;        type: String,&#10;        trim: true,&#10;        maxlength: [200, 'Les détails ne peuvent pas dépasser 200 caractères']&#10;      }&#10;    }&#10;  },&#10;&#10;  // 3. Indicateurs d'Investissement et d'Emploi&#10;  investissementEmploi: {&#10;    effectifsEmployes: {&#10;      type: Number,&#10;      required: [true, 'Le nombre d\'employés est requis'],&#10;      min: [0, 'Le nombre d\'employés ne peut pas être négatif']&#10;    },&#10;    nouveauxEmploisCrees: {&#10;      type: Number,&#10;      default: 0,&#10;      min: [0, 'Le nombre de nouveaux emplois ne peut pas être négatif']&#10;    },&#10;    nouveauxInvestissementsRealises: {&#10;      type: Boolean,&#10;      default: false&#10;    },&#10;    typesInvestissements: {&#10;      immobiliers: { type: Boolean, default: false },&#10;      mobiliers: { type: Boolean, default: false },&#10;      incorporels: { type: Boolean, default: false },&#10;      financiers: { type: Boolean, default: false }&#10;    }&#10;  },&#10;&#10;  // 4. Indicateurs d'Innovation et de Digitalisation&#10;  innovationDigitalisation: {&#10;    integrationInnovation: {&#10;      type: Number,&#10;      min: 1,&#10;      max: 3,&#10;      default: 1&#10;    },&#10;    integrationEconomieNumerique: {&#10;      type: Number,&#10;      min: 1,&#10;      max: 3,&#10;      default: 1&#10;    },&#10;    utilisationIA: {&#10;      type: Number,&#10;      min: 1,&#10;      max: 3,&#10;      default: 1&#10;    }&#10;  },&#10;&#10;  // 5. Indicateurs liés aux Conventions&#10;  conventions: {&#10;    respectDelaisReporting: {&#10;      conforme: { type: Boolean, default: true },&#10;      joursRetard: { type: Number, default: 0, min: 0 }&#10;    },&#10;    atteinteCiblesInvestissement: {&#10;      type: Number,&#10;      min: 0,&#10;      max: 100,&#10;      default: 0&#10;    },&#10;    atteinteCiblesEmploi: {&#10;      type: Number,&#10;      min: 0,&#10;      max: 100,&#10;      default: 0&#10;    },&#10;    conformiteNormesSpecifiques: {&#10;      conforme: { type: Boolean, default: true },&#10;      niveauConformite: {&#10;        type: Number,&#10;        min: 1,&#10;        max: 5,&#10;        default: 5&#10;      }&#10;    }&#10;  },&#10;&#10;  // Informations de contact&#10;  contact: {&#10;    telephone: {&#10;      type: String,&#10;      required: false,&#10;      trim: true,&#10;      default: null,&#10;      validate: {&#10;        validator: function(v) {&#10;          // Only validate format when a value is provided&#10;          if (v === null || v === undefined || v === '') return true;&#10;          return /^[0-9+\-\s()]+$/.test(v);&#10;        },&#10;        message: 'Veuillez entrer un numéro de téléphone valide'&#10;      }&#10;    },&#10;    email: {&#10;      type: String,&#10;      required: [true, 'L\'email est requis'],&#10;      lowercase: true,&#10;      trim: true,&#10;      match: [/^\w+([.-]?\w+)*@\w+([.-]?\w+)*(\.\w{2,3})+$/, 'Veuillez entrer un email valide']&#10;    },&#10;    siteWeb: {&#10;      type: String,&#10;      trim: true,&#10;      match: [/^https?:\/\/.+/, 'Veuillez entrer une URL valide']&#10;    },&#10;    adresse: {&#10;      rue: {&#10;        type: String,&#10;        trim: true,&#10;        maxlength: [200, 'L\'adresse ne peut pas dépasser 200 caractères']&#10;      },&#10;      ville: {&#10;        type: String,&#10;        trim: true,&#10;        maxlength: [100, 'La ville ne peut pas dépasser 100 caractères']&#10;      },&#10;      codePostal: {&#10;        type: String,&#10;        trim: true,&#10;        maxlength: [10, 'Le code postal ne peut pas dépasser 10 caractères']&#10;      },&#10;      pays: {&#10;        type: String,&#10;        trim: true,&#10;        maxlength: [50, 'Le pays ne peut pas dépasser 50 caractères'],&#10;        default: 'Cameroun'&#10;      }&#10;    }&#10;  },&#10;&#10;  // Statut et métadonnées&#10;  statut: {&#10;    type: String,&#10;    enum: ['En attente', 'Actif', 'Inactif', 'Suspendu'],&#10;    default: 'En attente'&#10;  },&#10;  informationsCompletes: {&#10;    type: Boolean,&#10;    default: false&#10;  },&#10;  dateCreation: {&#10;    type: Date,&#10;    default: Date.now&#10;  },&#10;  dateModification: {&#10;    type: Date,&#10;    default: Date.now&#10;  },&#10;  description: {&#10;    type: String,&#10;    trim: true,&#10;    maxlength: [1000, 'La description ne peut pas dépasser 1000 caractères']&#10;  }&#10;}, {&#10;  timestamps: true,&#10;  toJSON: { virtuals: true },&#10;  toObject: { virtuals: true }&#10;});&#10;&#10;// Add virtual properties or methods here if needed&#10;entrepriseSchema.virtual('conventionsActives', {&#10;  ref: 'Convention',&#10;  localField: '_id',&#10;  foreignField: 'enterpriseId',&#10;  match: { status: 'ACTIVE' }&#10;});&#10;&#10;module.exports = mongoose.model('Entreprise', entrepriseSchema);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/models/Indicator.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/models/Indicator.js" />
              <option name="updatedContent" value="const mongoose = require('mongoose');&#10;&#10;const indicatorHistorySchema = new mongoose.Schema({&#10;  value: {&#10;    type: Number,&#10;    required: true&#10;  },&#10;  submittedAt: {&#10;    type: Date,&#10;    default: Date.now&#10;  },&#10;  submittedBy: {&#10;    type: mongoose.Schema.Types.ObjectId,&#10;    ref: 'User',&#10;    required: true&#10;  },&#10;  status: {&#10;    type: String,&#10;    enum: ['PENDING', 'VALIDATED', 'REJECTED'],&#10;    default: 'PENDING'&#10;  },&#10;  comment: String,&#10;  attachments: [{&#10;    name: String,&#10;    url: String,&#10;    uploadedAt: Date&#10;  }]&#10;});&#10;&#10;const indicatorSchema = new mongoose.Schema({&#10;  conventionId: {&#10;    type: mongoose.Schema.Types.ObjectId,&#10;    ref: 'Convention',&#10;    required: true&#10;  },&#10;  name: {&#10;    type: String,&#10;    required: true&#10;  },&#10;  description: String,&#10;  type: {&#10;    type: String,&#10;    enum: ['NUMERIC', 'PERCENTAGE', 'CURRENCY', 'BOOLEAN'],&#10;    required: true&#10;  },&#10;  unit: String,&#10;  frequency: {&#10;    type: String,&#10;    enum: ['MONTHLY', 'QUARTERLY', 'SEMI_ANNUAL', 'ANNUAL'],&#10;    required: true&#10;  },&#10;  targetValue: {&#10;    type: Number,&#10;    required: true&#10;  },&#10;  minValue: Number,&#10;  maxValue: Number,&#10;  currentValue: {&#10;    type: Number,&#10;    default: 0&#10;  },&#10;  status: {&#10;    type: String,&#10;    enum: ['ON_TRACK', 'AT_RISK', 'OFF_TRACK', 'NOT_STARTED'],&#10;    default: 'NOT_STARTED'&#10;  },&#10;  nextReportingDate: Date,&#10;  history: [indicatorHistorySchema],&#10;  metadata: {&#10;    createdBy: {&#10;      type: mongoose.Schema.Types.ObjectId,&#10;      ref: 'User'&#10;    },&#10;    lastModifiedBy: {&#10;      type: mongoose.Schema.Types.ObjectId,&#10;      ref: 'User'&#10;    },&#10;    createdAt: {&#10;      type: Date,&#10;      default: Date.now&#10;    },&#10;    updatedAt: Date&#10;  }&#10;}, {&#10;  timestamps: true&#10;});&#10;&#10;// Calculate status based on current value vs target&#10;indicatorSchema.methods.calculateStatus = function() {&#10;  if (!this.currentValue) return 'NOT_STARTED';&#10;  &#10;  const percentage = (this.currentValue / this.targetValue) * 100;&#10;  &#10;  if (percentage &gt;= 90) return 'ON_TRACK';&#10;  if (percentage &gt;= 70) return 'AT_RISK';&#10;  return 'OFF_TRACK';&#10;};&#10;&#10;// Add a new value to history&#10;indicatorSchema.methods.addHistoryEntry = function(value, userId, attachments = [], comment = '') {&#10;  this.history.push({&#10;    value,&#10;    submittedBy: userId,&#10;    attachments,&#10;    comment&#10;  });&#10;  &#10;  this.currentValue = value;&#10;  this.status = this.calculateStatus();&#10;  this.metadata.lastModifiedBy = userId;&#10;  this.metadata.updatedAt = new Date();&#10;};&#10;&#10;// Get next reporting date based on frequency&#10;indicatorSchema.methods.calculateNextReportingDate = function() {&#10;  const now = new Date();&#10;  let next = new Date();&#10;  &#10;  switch(this.frequency) {&#10;    case 'MONTHLY':&#10;      next.setMonth(now.getMonth() + 1);&#10;      break;&#10;    case 'QUARTERLY':&#10;      next.setMonth(now.getMonth() + 3);&#10;      break;&#10;    case 'SEMI_ANNUAL':&#10;      next.setMonth(now.getMonth() + 6);&#10;      break;&#10;    case 'ANNUAL':&#10;      next.setFullYear(now.getFullYear() + 1);&#10;      break;&#10;  }&#10;  &#10;  return next;&#10;};&#10;&#10;// Middleware to update status and next reporting date&#10;indicatorSchema.pre('save', function(next) {&#10;  if (this.isModified('currentValue')) {&#10;    this.status = this.calculateStatus();&#10;  }&#10;  &#10;  if (this.isModified('frequency') || !this.nextReportingDate) {&#10;    this.nextReportingDate = this.calculateNextReportingDate();&#10;  }&#10;  &#10;  next();&#10;});&#10;&#10;module.exports = mongoose.model('Indicator', indicatorSchema);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/models/KPI.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/models/KPI.js" />
              <option name="updatedContent" value="const mongoose = require('mongoose');&#10;&#10;const kpiSubmissionSchema = new mongoose.Schema({&#10;  value: {&#10;    type: Number,&#10;    required: true&#10;  },&#10;  date: {&#10;    type: Date,&#10;    required: true,&#10;    default: Date.now&#10;  },&#10;  submittedBy: {&#10;    type: mongoose.Schema.Types.ObjectId,&#10;    ref: 'User',&#10;    required: true&#10;  },&#10;  status: {&#10;    type: String,&#10;    enum: ['pending', 'validated', 'rejected'],&#10;    default: 'pending'&#10;  },&#10;  comment: String&#10;});&#10;&#10;const kpiSchema = new mongoose.Schema({&#10;  name: {&#10;    type: String,&#10;    required: true&#10;  },&#10;  description: String,&#10;  targetValue: {&#10;    type: Number,&#10;    required: true&#10;  },&#10;  unit: {&#10;    type: String,&#10;    required: true&#10;  },&#10;  frequency: {&#10;    type: String,&#10;    enum: ['daily', 'weekly', 'monthly', 'quarterly', 'yearly'],&#10;    required: true&#10;  },&#10;  enterpriseId: {&#10;    type: mongoose.Schema.Types.ObjectId,&#10;    ref: 'Entreprise',&#10;    required: true&#10;  },&#10;  history: [kpiSubmissionSchema]&#10;}, {&#10;  timestamps: true&#10;});&#10;&#10;kpiSchema.index({ enterpriseId: 1 });&#10;kpiSchema.index({ 'history.date': 1 });&#10;kpiSchema.index({ 'history.status': 1 });&#10;&#10;module.exports = mongoose.model('KPI', kpiSchema);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/models/Visit.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/models/Visit.js" />
              <option name="updatedContent" value="const mongoose = require('mongoose');&#10;&#10;const visitSchema = new mongoose.Schema({&#10;  enterpriseId: {&#10;    type: mongoose.Schema.Types.ObjectId,&#10;    ref: 'Entreprise',&#10;    required: true&#10;  },&#10;  inspectorId: {&#10;    type: mongoose.Schema.Types.ObjectId,&#10;    ref: 'User'&#10;  },&#10;  scheduledAt: {&#10;    type: Date,&#10;    required: true&#10;  },&#10;  status: {&#10;    type: String,&#10;    enum: ['SCHEDULED', 'COMPLETED', 'CANCELLED'],&#10;    default: 'SCHEDULED'&#10;  },&#10;  type: {&#10;    type: String,&#10;    enum: ['REGULAR', 'FOLLOW_UP', 'EMERGENCY'],&#10;    required: true&#10;  },&#10;  report: {&#10;    content: String,&#10;    files: [{&#10;      name: String,&#10;      url: String&#10;    }],&#10;    submittedAt: Date,&#10;    submittedBy: {&#10;      type: mongoose.Schema.Types.ObjectId,&#10;      ref: 'User'&#10;    },&#10;    outcome: {&#10;      type: String,&#10;      enum: ['COMPLIANT', 'NON_COMPLIANT', 'NEEDS_FOLLOW_UP']&#10;    }&#10;  },&#10;  cancellationReason: String&#10;}, {&#10;  timestamps: true&#10;});&#10;&#10;visitSchema.index({ enterpriseId: 1, scheduledAt: 1 });&#10;visitSchema.index({ status: 1 });&#10;visitSchema.index({ inspectorId: 1 });&#10;&#10;module.exports = mongoose.model('Visit', visitSchema);" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/routes/admin.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/routes/admin.js" />
              <option name="originalContent" value="const express = require('express');&#10;const { query, validationResult } = require('express-validator');&#10;const AuditLog = require('../models/AuditLog');&#10;const { proteger, estAdmin } = require('../middleware/auth');&#10;&#10;const router = express.Router();&#10;&#10;// @route   GET /api/admin/dashboard&#10;// @desc    Obtenir le tableau de bord d'administration&#10;// @access  Private (Admin)&#10;router.get('/dashboard', proteger, estAdmin, async (req, res) =&gt; {&#10;  try {&#10;    // TODO: Implement dashboard statistics logic&#10;    res.json({ message: 'Admin dashboard route' });&#10;" />
              <option name="updatedContent" value="const express = require('express');&#10;const { query, validationResult } = require('express-validator');&#10;const AuditLog = require('../models/AuditLog');&#10;const { proteger, autoriser } = require('../middleware/auth');&#10;&#10;const router = express.Router();&#10;&#10;// @route   GET /api/admin/dashboard&#10;// @desc    Obtenir le tableau de bord d'administration&#10;// @access  Private (Admin)&#10;router.get('/dashboard', proteger, autoriser('ADMIN'), async (req, res) =&gt; {&#10;  try {&#10;    // Get admin dashboard statistics&#10;    const stats = {&#10;      users: 0, // TODO: Implement actual statistics&#10;      visits: 0,&#10;      documents: 0&#10;    };&#10;    res.json(stats);&#10;  } catch (err) {&#10;    console.error(err.message);&#10;    res.status(500).send('Erreur serveur');&#10;  }&#10;});&#10;&#10;// @route   GET /api/admin/activity&#10;// @desc    Obtenir les statistiques d'activité&#10;// @access  Private (Admin)&#10;router.get('/activity', proteger, autoriser('ADMIN'), async (req, res) =&gt; {&#10;  try {&#10;    const logs = await AuditLog.find().sort({ date: -1 }).limit(100);&#10;    res.json(logs);&#10;  } catch (err) {&#10;    console.error(err.message);&#10;    res.status(500).send('Erreur serveur');&#10;  }&#10;});&#10;&#10;module.exports = router;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/routes/conventions.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/routes/conventions.js" />
              <option name="updatedContent" value="const express = require('express');&#10;const router = express.Router();&#10;const conventionController = require('../controllers/conventionController');&#10;const { proteger } = require('../middleware/auth');&#10;&#10;// Protect all routes&#10;router.use(proteger);&#10;&#10;// Create a new convention&#10;router.post('/', conventionController.createConvention);&#10;&#10;// Get conventions for an enterprise&#10;router.get('/enterprise/:enterpriseId', conventionController.getConventionsByEnterprise);&#10;&#10;// Get active conventions for an enterprise&#10;router.get('/enterprise/:enterpriseId/active', conventionController.getActiveConventions);&#10;&#10;// Update convention details&#10;router.put('/:id', conventionController.updateConvention);&#10;&#10;// Update convention status&#10;router.patch('/:id/status', conventionController.updateConventionStatus);&#10;&#10;// Add document to convention&#10;router.post('/:id/documents', conventionController.addDocumentToConvention);&#10;&#10;// Get convention history&#10;router.get('/:id/history', conventionController.getConventionHistory);&#10;&#10;// Get convention summary&#10;router.get('/:id/summary', conventionController.getConventionSummary);&#10;&#10;module.exports = router;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/routes/documents.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/routes/documents.js" />
              <option name="updatedContent" value="const express = require('express');&#10;const router = express.Router();&#10;const documentController = require('../controllers/documentController');&#10;const { proteger } = require('../middleware/auth');&#10;const multer = require('multer');&#10;const upload = multer({ storage: multer.memoryStorage() });&#10;&#10;// Protected routes requiring authentication&#10;router.use(proteger);&#10;&#10;// Get all documents for a company&#10;router.get('/company/:companyId', documentController.getCompanyDocuments);&#10;&#10;// Upload a new document&#10;router.post('/company/:companyId/upload', upload.single('file'), documentController.uploadDocument);&#10;&#10;// Validate a document&#10;router.put('/:id/validate', documentController.validateDocument);&#10;&#10;// Delete a document&#10;router.delete('/:id', documentController.deleteDocument);&#10;&#10;// Get document types&#10;router.get('/types', documentController.getDocumentTypes);&#10;&#10;module.exports = router;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/routes/entreprises.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/routes/entreprises.js" />
              <option name="originalContent" value="const express = require('express');&#10;const { body } = require('express-validator');&#10;const { proteger, autoriser } = require('../middleware/auth');&#10;const {&#10;  getEntreprises,&#10;  getEntreprise,&#10;  createEntreprise,&#10;  updateEntreprise,&#10;  deleteEntreprise&#10;} = require('../controllers/entrepriseController');&#10;&#10;const router = express.Router();&#10;&#10;// Validation for creation (required fields)&#10;const validationCreate = [&#10;  body('nomEntreprise')&#10;    .trim()&#10;    .isLength({ min: 2, max: 200 })&#10;    .withMessage(&quot;Le nom de l'entreprise doit contenir entre 2 et 200 caracteres&quot;),&#10;  body('region')&#10;    .isIn([&#10;      'Adamaoua', 'Centre', 'Est', 'Extreme-Nord', 'Littoral',&#10;      'Nord', 'Nord-Ouest', 'Ouest', 'Sud', 'Sud-Ouest'&#10;    ])&#10;    .withMessage('Region invalide'),&#10;  body('ville')&#10;    .trim()&#10;    .isLength({ min: 2, max: 100 })&#10;    .withMessage('La ville doit contenir entre 2 et 100 caracteres'),&#10;  body('dateCreation')&#10;    .isISO8601()&#10;    .withMessage('Date de creation invalide'),&#10;  body('secteurActivite')&#10;    .isIn(['Primaire', 'Secondaire', 'Tertiaire'])&#10;    .withMessage(&quot;Secteur d'activite invalide&quot;),&#10;  body('sousSecteur')&#10;    .isIn([&#10;      'Agro-industriel', 'Foret-Bois', 'Mines', 'Petrole-Gaz',&#10;      'Industrie manufacturiere', 'BTP', 'Energie', 'Eau',&#10;      'Commerce', 'Transport', 'Telecommunications', 'Banque-Assurance',&#10;      'Tourisme', 'Sante', 'Education', 'Autres'&#10;    ])&#10;    .withMessage('Sous-secteur invalide')&#10;];&#10;&#10;// Validation for updates: all fields optional to allow partial updates&#10;const validationUpdate = [&#10;  body('nomEntreprise')&#10;    .optional({ checkFalsy: true })&#10;    .trim()&#10;    .isLength({ min: 2, max: 200 })&#10;    .withMessage(&quot;Le nom de l'entreprise doit contenir entre 2 et 200 caracteres&quot;),&#10;  body('region')&#10;    .optional({ checkFalsy: true })&#10;    .isIn([&#10;      'Adamaoua', 'Centre', 'Est', 'Extreme-Nord', 'Littoral',&#10;      'Nord', 'Nord-Ouest', 'Ouest', 'Sud', 'Sud-Ouest'&#10;    ])&#10;    .withMessage('Region invalide'),&#10;  body('ville')&#10;    .optional({ checkFalsy: true })&#10;    .trim()&#10;    .isLength({ min: 2, max: 100 })&#10;    .withMessage('La ville doit contenir entre 2 et 100 caracteres'),&#10;  body('dateCreation')&#10;    .optional({ checkFalsy: true })&#10;    .isISO8601()&#10;    .withMessage('Date de creation invalide'),&#10;  body('secteurActivite')&#10;    .optional({ checkFalsy: true })&#10;    .isIn(['Primaire', 'Secondaire', 'Tertiaire'])&#10;    .withMessage(&quot;Secteur d'activite invalide&quot;),&#10;  body('sousSecteur')&#10;    .optional({ checkFalsy: true })&#10;    .isIn([&#10;      'Agro-industriel', 'Foret-Bois', 'Mines', 'Petrole-Gaz',&#10;      'Industrie manufacturiere', 'BTP', 'Energie', 'Eau',&#10;      'Commerce', 'Transport', 'Telecommunications', 'Banque-Assurance',&#10;      'Tourisme', 'Sante', 'Education', 'Autres'&#10;    ])&#10;    .withMessage('Sous-secteur invalide')&#10;};&#10;&#10;// Routes&#10;router.get('/', proteger, getEntreprises);&#10;router.get('/:id', proteger, getEntreprise);&#10;router.post('/', proteger, autoriser('admin'), validationCreate, createEntreprise);&#10;router.put('/:id', proteger, validationUpdate, updateEntreprise);&#10;router.delete('/:id', proteger, autoriser('admin'), deleteEntreprise);&#10;&#10;module.exports = router;&#10;" />
              <option name="updatedContent" value="const express = require('express');&#10;const { body } = require('express-validator');&#10;const { proteger, autoriser } = require('../middleware/auth');&#10;const {&#10;  getEntreprises,&#10;  getEntreprise,&#10;  createEntreprise,&#10;  updateEntreprise,&#10;  deleteEntreprise&#10;} = require('../controllers/entrepriseController');&#10;&#10;const router = express.Router();&#10;&#10;// Validation for creation (required fields)&#10;const validationCreate = [&#10;  body('nomEntreprise')&#10;    .trim()&#10;    .isLength({ min: 2, max: 200 })&#10;    .withMessage(&quot;Le nom de l'entreprise doit contenir entre 2 et 200 caracteres&quot;),&#10;  body('region')&#10;    .isIn([&#10;      'Adamaoua', 'Centre', 'Est', 'Extreme-Nord', 'Littoral',&#10;      'Nord', 'Nord-Ouest', 'Ouest', 'Sud', 'Sud-Ouest'&#10;    ])&#10;    .withMessage('Region invalide'),&#10;  body('ville')&#10;    .trim()&#10;    .isLength({ min: 2, max: 100 })&#10;    .withMessage('La ville doit contenir entre 2 et 100 caracteres'),&#10;  body('dateCreation')&#10;    .isISO8601()&#10;    .withMessage('Date de creation invalide'),&#10;  body('secteurActivite')&#10;    .isIn(['Primaire', 'Secondaire', 'Tertiaire'])&#10;    .withMessage(&quot;Secteur d'activite invalide&quot;),&#10;  body('sousSecteur')&#10;    .isIn([&#10;      'Agro-industriel', 'Foret-Bois', 'Mines', 'Petrole-Gaz',&#10;      'Industrie manufacturiere', 'BTP', 'Energie', 'Eau',&#10;      'Commerce', 'Transport', 'Telecommunications', 'Banque-Assurance',&#10;      'Tourisme', 'Sante', 'Education', 'Autres'&#10;    ])&#10;    .withMessage('Sous-secteur invalide')&#10;];&#10;&#10;// Validation for updates: all fields optional to allow partial updates&#10;const validationUpdate = [&#10;  body('nomEntreprise')&#10;    .optional({ checkFalsy: true })&#10;    .trim()&#10;    .isLength({ min: 2, max: 200 })&#10;    .withMessage(&quot;Le nom de l'entreprise doit contenir entre 2 et 200 caracteres&quot;),&#10;  body('region')&#10;    .optional({ checkFalsy: true })&#10;    .isIn([&#10;      'Adamaoua', 'Centre', 'Est', 'Extreme-Nord', 'Littoral',&#10;      'Nord', 'Nord-Ouest', 'Ouest', 'Sud', 'Sud-Ouest'&#10;    ])&#10;    .withMessage('Region invalide'),&#10;  body('ville')&#10;    .optional({ checkFalsy: true })&#10;    .trim()&#10;    .isLength({ min: 2, max: 100 })&#10;    .withMessage('La ville doit contenir entre 2 et 100 caracteres'),&#10;  body('dateCreation')&#10;    .optional({ checkFalsy: true })&#10;    .isISO8601()&#10;    .withMessage('Date de creation invalide'),&#10;  body('secteurActivite')&#10;    .optional({ checkFalsy: true })&#10;    .isIn(['Primaire', 'Secondaire', 'Tertiaire'])&#10;    .withMessage(&quot;Secteur d'activite invalide&quot;),&#10;  body('sousSecteur')&#10;    .optional({ checkFalsy: true })&#10;    .isIn([&#10;      'Agro-industriel', 'Foret-Bois', 'Mines', 'Petrole-Gaz',&#10;      'Industrie manufacturiere', 'BTP', 'Energie', 'Eau',&#10;      'Commerce', 'Transport', 'Telecommunications', 'Banque-Assurance',&#10;      'Tourisme', 'Sante', 'Education', 'Autres'&#10;    ])&#10;    .withMessage('Sous-secteur invalide')&#10;];&#10;&#10;// Routes&#10;router.get('/', proteger, getEntreprises);&#10;router.get('/:id', proteger, getEntreprise);&#10;router.post('/', proteger, autoriser('admin'), validationCreate, createEntreprise);&#10;router.put('/:id', proteger, validationUpdate, updateEntreprise);&#10;router.delete('/:id', proteger, autoriser('admin'), deleteEntreprise);&#10;&#10;module.exports = router;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/routes/indicators.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/routes/indicators.js" />
              <option name="originalContent" value="const express = require('express');&#10;const router = express.Router();&#10;const indicatorController = require('../controllers/indicatorController');&#10;const auth = require('../middleware/auth');&#10;router.use(auth);&#10;router.use(auth);&#10;router.use(auth);&#10;router.post('/', indicatorController.createIndicator);&#10;" />
              <option name="updatedContent" value="const express = require('express');&#10;const router = express.Router();&#10;const indicatorController = require('../controllers/indicatorController');&#10;const { proteger } = require('../middleware/auth');&#10;const { checkPermission } = require('../middleware/roles');&#10;const { validateIndicatorSubmission } = require('../middleware/indicatorValidation');&#10;&#10;// Protect all routes&#10;router.use(proteger);&#10;&#10;// Create a new indicator&#10;router.post('/',&#10;  checkPermission('indicators', 'create'),&#10;  indicatorController.createIndicator&#10;);&#10;&#10;// Get all indicators for a convention&#10;router.get('/convention/:conventionId',&#10;  checkPermission('indicators', 'read'),&#10;  indicatorController.getIndicatorsByConvention&#10;);&#10;&#10;// Get indicator report for a convention&#10;router.get('/convention/:conventionId/report',&#10;  checkPermission('indicators', 'read'),&#10;  indicatorController.getIndicatorsReport&#10;);&#10;&#10;// Get specific indicator details&#10;router.get('/:id',&#10;  checkPermission('indicators', 'read'),&#10;  indicatorController.getIndicatorDetails&#10;);&#10;&#10;// Update indicator details&#10;router.put('/:id',&#10;  checkPermission('indicators', 'update'),&#10;  indicatorController.updateIndicator&#10;);&#10;&#10;// Submit new value for an indicator&#10;router.post('/:id/submit',&#10;  checkPermission('indicators', 'submit'),&#10;  validateIndicatorSubmission,&#10;  indicatorController.submitIndicatorValue&#10;);&#10;&#10;// Validate an indicator submission&#10;router.patch('/:id/submissions/:submissionId/validate',&#10;  checkPermission('indicators', 'validate'),&#10;  indicatorController.validateIndicatorSubmission&#10;);&#10;&#10;// Get indicator history&#10;router.get('/:id/history',&#10;  checkPermission('indicators', 'read'),&#10;  indicatorController.getIndicatorHistory&#10;);&#10;&#10;module.exports = router;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/server/routes/kpis.js">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/server/routes/kpis.js" />
              <option name="updatedContent" value="const express = require('express');&#10;const router = express.Router();&#10;const kpiController = require('../controllers/kpiController');&#10;const { proteger } = require('../middleware/auth');&#10;&#10;// Protected routes requiring authentication&#10;router.use(proteger);&#10;&#10;// Get KPIs for an enterprise&#10;router.get('/enterprise/:enterpriseId', kpiController.getKPIsByEnterprise);&#10;&#10;// Submit a new KPI value&#10;router.post('/:kpiId/submit', kpiController.submitKPIValue);&#10;&#10;// Validate a KPI submission&#10;router.put('/:kpiId/submissions/:submissionId', kpiController.validateKPISubmission);&#10;&#10;// Get KPI history&#10;router.get('/:kpiId/history', kpiController.getKPIHistory);&#10;&#10;// Get KPI overview for an enterprise&#10;router.get('/enterprise/:enterpriseId/overview', kpiController.getKPIOverview);&#10;&#10;module.exports = router;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>